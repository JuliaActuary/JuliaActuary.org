<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta name=Description  content="Practical, extensible, and open-source actuarial modeling and analysis."> <meta property="og:description" content="Practical, extensible, and open-source actuarial modeling and analysis."> <meta property="og:image" content="/assets/logo_square.svg"> <script> MathJax = { tex: { inlineMath: [['$', '$'], ["\\(", "\\)"]], processEscapes: true, } }; </script> <script async src="/assets/MathJax/MathJax-3.2.2/es5/tex-mml-chtml.js"> </script> <style> @font-face { src: url("//assets/MathJax/MathJax-3.2.2/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff"> } </style> <style> @font-face { src: url("//assets/MathJax/MathJax-3.2.2/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff"> } </style> <style> @font-face { src: url("//assets/MathJax/MathJax-3.2.2/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff"> } </style> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>FinanceModels.jl - Evolving the JuliaActuary Ecosystem | JuliaActuary</title> <link rel=apple-touch-icon  sizes=180x180  href="/assets/apple-touch-icon.png"> <link rel=icon  type="image/png" sizes=32x32  href="/assets/favicon-32x32.png"> <link rel=icon  type="image/png" sizes=16x16  href="/assets/favicon-16x16.png"> <link rel=manifest  href="/assets/site.webmanifest"> <script src="https://cdn.jsdelivr.net/npm/swiffy-slider@1.2.0/dist/js/swiffy-slider.min.js" crossorigin=anonymous  defer></script> <link href="/css/slider.css" rel=stylesheet > <header> <div class=blog-name > <a href="/"> <div class=blog-name-logo-container > <div class=blog-name-logo > <img src="/assets/logo_square.svg" alt=logo  height=100px  width=100px  /> </div> <div>JuliaActuary</div> </div> </a> <div class=tagline >Practical, extensible, and open-source actuarial modeling and analysis. </div> </div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/packages">Packages</a> <li><a href="/community">Community</a> <ul> <li><a href="/community/#learn">Learn</a> <li><a href="/community/#integration_with_r_and_python">Integration</a> <li><a href="/community/#contributing">Contributing</a> </ul> <li><a href="/#blog">Blog</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=financemodelsjl_-_evolving_the_juliaactuary_ecosystem ><a href="#financemodelsjl_-_evolving_the_juliaactuary_ecosystem" class=header-anchor >FinanceModels.jl - Evolving the JuliaActuary Ecosystem</a></h1> <p>Yields.jl has evolved into FinanceModels.jl. The benefits are:</p> <ul> <li><p>Provide a composable set of <strong>contracts</strong> and <strong><code>Quotes</code></strong> </p> <li><p>Those contracts, when combined with a <strong>model</strong> produce a <strong><code>Cashflow</code></strong> via a flexibly defined <code>Projection</code></p> <li><p><strong>models</strong> can be <code>fit</code> with a new unified API: <code>fit&#40;model_type,quotes,fit_method&#41;</code></p> </ul> <p>This blog post describes the conceptual overview and motivation for the change.</p> <h2 id=finance_models_overview ><a href="#finance_models_overview" class=header-anchor >Finance Models Overview</a></h2> <p><strong>FinanceModels.jl</strong> provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.</p> <p><img src="/blog/assets/relations.png" alt="A conceptual sketch of FinanceModels.jl" /></p> <h2 id=cashflow_-_a_fundamental_financial_type ><a href="#cashflow_-_a_fundamental_financial_type" class=header-anchor ><ol> <li><p><code>Cashflow</code> - a fundamental financial type</p> </ol> </a></h2> <p>Say you wanted to model a contract that paid quarterly payments, and those payments occurred starting 15 days from the valuation date &#40;first payment time &#61; 15/365 &#61; 0.057&#41;</p> <p>Previously, you had two options:</p> <ol> <li><p>Choose a discrete timestep to model &#40;e.g. monthly, quarterly, annual&#41; and then lump the cashflows into those timesteps. E.g. with monthly timesteps of a unit payment of our contract, it might look like: <code>&#91;1,0,0,1,0,0...&#93;</code></p> <li><p>Keep track of two vectors: one for the payment and one for the times. In this case, that might look like: <code>cfs &#61; &#91;1,1,...&#93;;</code>times &#61; <code>&#91;0.057, 0.307...&#93;</code></p> </ol> <p>The former has inaccuracies due to the simplified timing and logical complication related to mapping the contracts natural periodicity into an arbitrary modeling choice. The latter becomes unwieldy and fails to take advantage of Julia&#39;s type system. </p> <p>The new solution: <code>Cashflow</code>s. Our example above would become: <code>&#91;Cashflow&#40;1,0.057&#41;, Cashflow&#40;1,0.307&#41;,...&#93;</code></p> <h2 id=ol_start2_contracts_-_a_composable_way_to_represent_financial_instruments ><a href="#ol_start2_contracts_-_a_composable_way_to_represent_financial_instruments" class=header-anchor ><ol start=2 > <li><p><strong>Contracts</strong> - A composable way to represent financial instruments</p> </ol> </a></h2> <p>Contracts are a composable way to represent financial instruments. They are, in essence, anything that is a collection of cashflows. Contracts can be combined to represent more complex instruments. For example, a bond can be represented as a collection of cashflows that correspond to the coupon payments and the principal repayment.</p> <p>Examples:</p> <ul> <li><p>a <code>Cashflow</code></p> <li><p><code>Bond</code>s:</p> <ul> <li><p><code>Bond.Fixed</code>, <code>Bond.Floating</code></p> </ul> <li><p><code>Option</code>s:</p> <ul> <li><p><code>Option.EuroCall</code> and <code>Option.EuroPut</code> </p> </ul> <li><p>Compositional contracts:</p> <ul> <li><p><code>Forward</code>to represent an instrument that is relative to a forward point in time.</p> <li><p><code>Composite</code> to represent the combination of two other instruments. </p> </ul> </ul> <p>In the future, this notion may be extended to liabilities &#40;e.g. insurance policies in LifeContingencies.jl&#41;</p> <h3 id=creating_a_new_contract ><a href="#creating_a_new_contract" class=header-anchor >Creating a new Contract</a></h3> <p>A contract is anything that creates a vector of <code>Cashflow</code>s when <code>collect</code>ed. For example, let&#39;s create a bond which only pays down principle and offers no coupons.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> FinanceModels,FinanceCore

<span class=hljs-comment ># Transducers is used to provide a more powerful, composable way to construct collections than the basic iteration interface</span>
<span class=hljs-keyword >using</span> Transducers: __foldl__, <span class=hljs-meta >@next</span>, complete

<span class=hljs-string >&quot;&quot;&quot;
A bond which pays down its par (one unit) in equal payments. 
&quot;&quot;&quot;</span>
<span class=hljs-keyword >struct</span> PrincipalOnlyBond{F&lt;:FinanceCore.Frequency} &lt;: FinanceModels.Bond.AbstractBond
    frequency::F
    maturity::<span class=hljs-built_in >Float64</span>
<span class=hljs-keyword >end</span>

<span class=hljs-comment ># We extend the interface to say what should happen as the bond is projected</span>
<span class=hljs-comment ># There&#x27;s two parts to customize:</span>
<span class=hljs-comment ># 1. any initialization or state to keep track of</span>
<span class=hljs-comment ># 2. The loop where we decide what gets returned at each timestep</span>
<span class=hljs-keyword >function</span> Transducers.__foldl__(rf, val, p::Projection{C,M,K}) <span class=hljs-keyword >where</span> {C&lt;:PrincipalOnlyBond,M,K}
    <span class=hljs-comment ># initialization stuff</span>
    b = p.contract <span class=hljs-comment ># the contract within a projection</span>
    ts = Bond.coupon_times(b) <span class=hljs-comment ># works since it&#x27;s a FinanceModels.Bond.AbstractBond with a frequency and maturity</span>
    pmt = <span class=hljs-number >1</span> / length(ts)

    <span class=hljs-keyword >for</span> t <span class=hljs-keyword >in</span> ts
        <span class=hljs-comment ># the loop which returns a value</span>
        cf = Cashflow(pmt, t)
        val = <span class=hljs-meta >@next</span>(rf, val, cf) <span class=hljs-comment ># the value to return is the last argument</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> complete(rf, val)
<span class=hljs-keyword >end</span></code></pre> <p>That&#39;s it&#33; then we can use this contract to fitting models, create projections, quotes, etc. Here we simply collect the bond into an array of cashflows:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > PrincipalOnlyBond(Periodic(<span class=hljs-number >2</span>),<span class=hljs-number >5.</span>) |&gt; collect
</span>10-element Vector{Cashflow{Float64, Float64}}:
 Cashflow{Float64, Float64}(0.1, 0.5)
 Cashflow{Float64, Float64}(0.1, 1.0)
 Cashflow{Float64, Float64}(0.1, 1.5)
 Cashflow{Float64, Float64}(0.1, 2.0)
 Cashflow{Float64, Float64}(0.1, 2.5)
 Cashflow{Float64, Float64}(0.1, 3.0)
 Cashflow{Float64, Float64}(0.1, 3.5)
 Cashflow{Float64, Float64}(0.1, 4.0)
 Cashflow{Float64, Float64}(0.1, 4.5)
 Cashflow{Float64, Float64}(0.1, 5.0)</code></pre> <p>Note that all contracts in FinanceModels.jl are currently <em>unit</em> contracts in that they assume a unit par value. Scale assets down to unit values before constructing the default contracts.</p> <h4 id=more_complex_contracts ><a href="#more_complex_contracts" class=header-anchor >More complex Contracts</a></h4> <p><strong>When the cashflow depends on a model</strong>. An example of this is a floating bond where the coupon paid depends on a view of forward rates. See <strong>Section 6 - Projections</strong> for how this is handled.</p> <h2 id=ol_start3_quotes_-_the_observed_price_we_need_to_fit_a_model_to ><a href="#ol_start3_quotes_-_the_observed_price_we_need_to_fit_a_model_to" class=header-anchor ><ol start=3 > <li><p><code>Quote</code>s - The observed price we need to fit a model to</p> </ol> </a></h2> <p>Quotes are the observed prices that we need to fit a model to. They represent the market prices of financial instruments, such as bonds or swaps. In the context of the package, a quote is defined as a pair of a contract and a price.</p> <p>For example, a par yield bond paying a 4&#37; coupon &#40;paid as 2&#37; twice per annum&#41; implies a price at par &#40;i.e. <code>1.0</code>&#41;:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > ParYield(Periodic(<span class=hljs-number >0.04</span>,<span class=hljs-number >2</span>),<span class=hljs-number >10</span>)
</span>Quote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(
1.0, 
FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.040000000000000036, Periodic(2), 10))</code></pre> <p>A number of convenience functions are included to construct a <code>Quote</code>:</p> <ul> <li><p><code>ZCBPrice</code> and <code>ZCBYield</code></p> <li><p><code>ParYield</code></p> <li><p><code>CMTYield</code></p> <li><p><code>OISYield</code></p> <li><p><code>ForwardYields</code></p> </ul> <h2 id=ol_start4_models_-_not_just_yield_curves_anymore ><a href="#ol_start4_models_-_not_just_yield_curves_anymore" class=header-anchor ><ol start=4 > <li><p><strong>Models</strong> - Not just yield curves anymore</p> </ol> </a></h2> <ul> <li><p><strong>Yield Curves</strong>: all of Yields.jl yield models are included in the initial FinanceModels.jl release</p> <li><p><strong>Equities and Options</strong>: The initial release includes <code>BlackScholesMerton</code> option pricing and one can use constant or spline volatility models</p> <li><p><strong>Others</strong> more to come in the future</p> </ul> <h3 id=creating_a_new_model ><a href="#creating_a_new_model" class=header-anchor >Creating a new model</a></h3> <p>Here we&#39;ll do a complete implementation of a yield curve model where the discount rate is approximated by a straight line &#40;often called an AB line from the <code>y&#61;ax&#43;b</code> formula.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> FinanceModels, FinanceCore
 <span class=hljs-keyword >using</span> AccessibleOptimization 
 <span class=hljs-keyword >using</span> IntervalSets
 
<span class=hljs-keyword >struct</span> ABDiscountLine{A} &lt;: FinanceModels.Yield.AbstractYieldModel
    a::A
    b::A
<span class=hljs-keyword >end</span>

ABDiscountLine() = ABDiscountLine(<span class=hljs-number >0.</span>,<span class=hljs-number >0.</span>)

<span class=hljs-keyword >function</span> FinanceCore.discount(m::ABDiscountLine,t)
    <span class=hljs-comment >#discount rate is approximated by a straight line, floored at 0.0 and capped at 1.0</span>
    clamp(m.a*t + m.b, <span class=hljs-number >0.0</span>,<span class=hljs-number >1.0</span>) 
<span class=hljs-keyword >end</span>


<span class=hljs-comment ># `@optic` indicates what in our model variables needs to be updated (from AccessibleOptimization.jl)</span>
<span class=hljs-comment ># `-1.0 .. 1.0` says to bound the search from negative to positive one (from IntervalSets.jl)</span>
FinanceModels.__default_optic(m::ABDiscountLine) = OptArgs([
    <span class=hljs-meta >@optic</span>(_.a) =&gt; -<span class=hljs-number >1.0</span> .. <span class=hljs-number >1.0</span>,
    <span class=hljs-meta >@optic</span>(_.b) =&gt; -<span class=hljs-number >1.0</span> .. <span class=hljs-number >1.0</span>,
]...)

quotes = ZCBPrice([<span class=hljs-number >0.9</span>, <span class=hljs-number >0.8</span>, <span class=hljs-number >0.7</span>,<span class=hljs-number >0.6</span>])

m = fit(ABDiscountLine(),quotes)</code></pre> <p>Now, <code>m</code> is a model like any of the other yield curve models provided and can be used in that context. For example, calculating the price of the bonds contained within our <code>quotes</code> where we indeed recover the prices for our contrived example:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > map(q -&gt; pv(m,q.instrument),quotes) 
</span>4-element Vector{Float64}:
 0.9
 0.8
 0.7
 0.6</code></pre> <h2 id=ol_start5_fit_-_the_standardized_api_for_all_models_quotes_and_methods ><a href="#ol_start5_fit_-_the_standardized_api_for_all_models_quotes_and_methods" class=header-anchor ><ol start=5 > <li><p><code>fit</code> - The standardized API for all models, quotes, and methods</p> </ol> </a></h2> <pre><code class="plaintext hljs">Model                                                               Method
          |                                                                   |
    |------------|                                                     |---------------|
fit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())
                    |-------------------------------------------------|
                                              |
                                              Quotes</code></pre> <ul> <li><p><strong>Model</strong> could be <code>Spline.Linear&#40;&#41;</code>, <code>Yield.NelsonSiegelSvensson&#40;&#41;</code>, <code>Equity.BlackScholesMerton&#40;...&#41;</code>, etc.</p> <li><p><strong>Quote</strong> could be <code>CMTYield</code>s, <code>ParYield</code>s, <code>Option.Eurocall</code>, etc.</p> <li><p><strong>Method</strong> could be <code>Fit.Loss&#40;x-&gt;x^2&#41;</code>, <code>Fit.Loss&#40;x-&gt;abs&#40;x&#41;&#41;</code>, <code>Fit.Bootstrap&#40;&#41;</code>, etc.</p> </ul> <p>The benefit of this versus the old Yields.jl API is:</p> <ul> <li><p>Without a generic <code>fit</code> method, no obvious way to expose different curve construction methods &#40;e.g. choice of model and method&#41;</p> <li><p>The <code>fit</code> is extensible. Users or other packages could define their own Models, Quotes, or Methods and integrate into the JuliaActuary ecosystem.</p> <li><p>The <code>fit</code> formulation is very generic: the required methods are minimal to integrate in order to extend the functionality.</p> </ul> <h3 id=customizing_model_fitting ><a href="#customizing_model_fitting" class=header-anchor >Customizing model fitting</a></h3> <p>Model fitting can be customized:</p> <ul> <li><p>The <strong>loss function</strong> &#40;least squares, absolute difference, etc.&#41; via the third argument to <code>fit</code>:</p> <ul> <li><p>e.g.<code>fit&#40;ABDiscountLine&#40;&#41;, quotes, FIt.Loss&#40;x -&gt; abs&#40;x&#41;&#41;</code></p> <li><p>the default is <code>Fit.Loss&#40;x-&gt;x^2&#41;</code></p> </ul> <li><p>the <strong>optimization algorithm</strong> by defining a method <code>FinanceModels.__default_optim__&#40;m::ABDiscountLine&#41; &#61; OptimizationOptimJL.Newton&#40;&#41;</code></p> <ul> <li><p>you may need to change the <code>__default_optic</code> to be unbounded &#40;simply omit the <code>&#61;&gt;</code> and subsequent bounds&#41;</p> <li><p>The default is OptimizationMetaheuristics.ECA&#40;&#41;</p> </ul> <li><p>The <strong>general algorithm</strong> can be customized by creating a new method for fit: </p> </ul> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> FinanceModels.fit(m::ABDiscountLine, quotes, ...)
	<span class=hljs-comment ># custom code for fitting your model here</span>
<span class=hljs-keyword >end</span></code></pre> <ul> <li><p>As an example, the splines &#40;<code>Spline.Linear&#40;&#41;</code>, <code>Spline.Cubic&#40;&#41;</code>,...&#41; are defined to use bootstrap by default: <code>fit&#40;mod0::Spline.BSpline, quotes, method::Fit.Bootstrap&#41;</code></p> </ul> <h3 id=using_models_without_fitting ><a href="#using_models_without_fitting" class=header-anchor >Using models without fitting</a></h3> <p>While many of the examples show models being fit to observed prices, you can skip that step in practice if you want to define an assumed valuation model that does not intend to calibrate market prices.</p> <h2 id=ol_start6_projections ><a href="#ol_start6_projections" class=header-anchor ><ol start=6 > <li><p><code>Projection</code>s</p> </ol> </a></h2> <p>A <code>Projection</code> is a generic way to work with various data that you can project forward. For example, getting the series of cashflows associated with a contract.</p> <p>What is a <code>Projection</code>?</p> <pre><code class="julia hljs"><span class=hljs-keyword >struct</span> Projection{C,M,K} &lt;: AbstractProjection
    contract::C    <span class=hljs-comment ># the contract (or set of contracts) we want to project</span>
    model::M       <span class=hljs-comment ># the model that defines how the contract will behave</span>
    kind::K           <span class=hljs-comment ># what kind of projection do we want? only cashflows? </span>
<span class=hljs-keyword >end</span></code></pre> <p><code>contract</code> is obvious, so let&#39;s talk more about the second two:</p> <ul> <li><p><code>model</code> is the same kind of thing we discussed above. Some contracts &#40;e.g. a floating rate bond&#41;. We can still decompose a floating rate bond into a set of cashflows, but we need a model. </p> <ul> <li><p>There are also projections which don&#39;t need a model &#40;e.g. fixed bonds&#41; and for that there&#39;s the generic <code>NullModel&#40;&#41;</code> </p> </ul> <li><p><code>kind</code> defines what we&#39;ll return from the projection.</p> <ul> <li><p><code>CashflowProjection&#40;&#41;</code> says we just want a <code>Cashflow&#91;...&#93;</code> vector</p> <li><p>... but if we wanted to extend this such that we got a vector containing cashflows, capital factors, default rates, etc we could define a new projection type &#40;e.g. we might call the above <code>AssetDetailProjection&#40;&#41;</code></p> <li><p>As of the time of announcement, only <code>CashflowProjection&#40;&#41;</code> is defined by FinanceModels.jl</p> </ul> </ul> <h3 id=contracts_that_depend_on_the_model_or_multiple_models ><a href="#contracts_that_depend_on_the_model_or_multiple_models" class=header-anchor >Contracts that depend on the model &#40;or multiple models&#41;</a></h3> <p>For example, the cashflows you generate for a floating rate bond is the current reference rate. Or maybe you have a stochastic volatility model and want to project forward option values. This type of dependency is handled like this:</p> <ul> <li><p>define <code>model</code> as a relation that maps a key to a model. E.g. a <code>Dict&#40;&quot;SOFR&quot; &#61;&gt; NelsonSiegelSvensson&#40;...&#41;&#41;</code></p> <li><p>when defining the logic for the reducible collection/foldl, you can reference the <code>Projection.model</code> by the associated key.</p> </ul> <p>Here&#39;s how a floating bond is implemented:</p> <p>The contract struct. The <code>key</code> would be &quot;SOFR&quot; in our example above.</p> <pre><code class="julia hljs"><span class=hljs-keyword >struct</span> Floating{F&lt;:FinanceCore.Frequency,N&lt;:<span class=hljs-built_in >Real</span>,M&lt;:Timepoint,K} &lt;: AbstractBond
    coupon_rate::N <span class=hljs-comment ># coupon_rate / frequency is the actual payment amount</span>
    frequency::F
    maturity::M
    key::K
<span class=hljs-keyword >end</span></code></pre> <p>And how we can reference the associated model when projecting that contract. This is very similar to the definition of <code>__foldl__</code> for our <code>PrincipalOnlyBond</code>, except we are paying a coupon and referencing the scenario rate.</p> <pre><code class="julia hljs"><span class=hljs-meta >@inline</span> <span class=hljs-keyword >function</span> Transducers.__foldl__(rf, val, p::Projection{C,M,K}) <span class=hljs-keyword >where</span> {C&lt;:Bond.Floating,M,K}
    b = p.contract
    ts = Bond.coupon_times(b)
    <span class=hljs-keyword >for</span> t <span class=hljs-keyword >in</span> ts
        freq = b.frequency <span class=hljs-comment ># e.g. `Periodic(2)`</span>
        freq_scalar = freq.frequency  <span class=hljs-comment ># the 2 from `Periodic(2)`</span>

        <span class=hljs-comment ># get the rate from the current time to next payment </span>
        <span class=hljs-comment ># out of the model and convert it to the contract&#x27;s periodicity</span>
        model = p.model[b.key]
        reference_rate = rate(freq(forward(model, t, t + <span class=hljs-number >1</span> / freq_scalar)))
        coup = (reference_rate + b.coupon_rate) / freq_scalar
        amt = <span class=hljs-keyword >if</span> t == last(ts)
            <span class=hljs-number >1.0</span> + coup
        <span class=hljs-keyword >else</span>
            coup
        <span class=hljs-keyword >end</span>
        cf = Cashflow(amt, t)
        val = <span class=hljs-meta >@next</span>(rf, val, cf)
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> complete(rf, val)
<span class=hljs-keyword >end</span></code></pre> <h2 id=ol_start7_projectionkinds ><a href="#ol_start7_projectionkinds" class=header-anchor ><ol start=7 > <li><p><code>ProjectionKind</code>s</p> </ol> </a></h2> <p>While <code>CashflowProjection</code> is the most common &#40;and the only one built into the initial release of FinanceModels&#41;, a <code>Projection</code> can be created which handles different kinds of outputs in the same manner as projecting just basic cashflows. For example, you may want to output an amortization schedule, or a financial statement, or an account value roll-forward. The <code>Projection</code> is able to handle these custom outputs by dispatching on the third element in a <code>Projection</code>.</p> <p>Let&#39;s extend the example of a principle-only bond from section 2 above. Our goal is to create a basic amortization schedule which shows the payment made and outstanding balance.</p> <p>First, we create a new subtype of <code>ProjectionKind</code>:</p> <pre><code class="julia hljs"><span class=hljs-keyword >struct</span> AmortizationSchedule &lt;: FinanceModels.ProjectionKind
<span class=hljs-keyword >end</span></code></pre> <p>And then define the loop for the amortization schedule output:</p> <pre><code class="julia hljs"><span class=hljs-comment ># note the dispatch on `AmortizationSchedule` in the next line</span>
<span class=hljs-keyword >function</span> Transducers.__foldl__(rf, val, p::Projection{C,M,K}) <span class=hljs-keyword >where</span> {C&lt;:PrincipalOnlyBond,M,K&lt;:AmortizationSchedule}
    <span class=hljs-comment ># initialization stuff</span>
    b = p.contract <span class=hljs-comment ># the contract within a projection</span>
    ts = Bond.coupon_times(b) <span class=hljs-comment ># works since it&#x27;s a FinanceModels.Bond.AbstractBond with a frequency and maturity</span>
    pmt = <span class=hljs-number >1</span> / length(ts)
    balance = <span class=hljs-number >1.0</span>
    <span class=hljs-keyword >for</span> t <span class=hljs-keyword >in</span> ts
        <span class=hljs-comment ># the loop which returns a tuple of the relevant data</span>
        balance -= pmt
        result = (time=t,payment=pmt,outstanding=balance)
        val = <span class=hljs-meta >@next</span>(rf, val, result) <span class=hljs-comment ># the value to return is the last argument</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> complete(rf, val)
<span class=hljs-keyword >end</span></code></pre> <p>We can now define the projection:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > p = Projection(
           PrincipalOnlyBond(Periodic(<span class=hljs-number >2</span>),<span class=hljs-number >5.</span>),  <span class=hljs-comment ># our contract</span>
           NullModel(),                       <span class=hljs-comment ># the projection doesn&#x27;t need a model, so use the null model</span>
           AmortizationSchedule(),            <span class=hljs-comment ># specify the amortization schedule output</span>
           );</span></code></pre> <p>And then collect the values:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > collect(p)
</span>10-element Vector{NamedTuple{(:time, :payment, :outstanding), Tuple{Float64, Float64, Float64}}}:
 (time = 0.5, payment = 0.1, outstanding = 0.9)
 (time = 1.0, payment = 0.1, outstanding = 0.8)
 (time = 1.5, payment = 0.1, outstnding = 0.7000000000000001)
 (time = 2.0, payment = 0.1, outstanding = 0.6000000000000001)
 (time = 2.5, payment = 0.1, outstanding = 0.5000000000000001)
 (time = 3.0, payment = 0.1, outstanding = 0.40000000000000013)
 (time = 3.5, payment = 0.1, outstanding = 0.30000000000000016)
 (time = 4.0, payment = 0.1, outstanding = 0.20000000000000015)
 (time = 4.5, payment = 0.1, outstanding = 0.10000000000000014)
 (time = 5.0, payment = 0.1, outstanding = 1.3877787807814457e-16)</code></pre> <h2 id=development_benefits ><a href="#development_benefits" class=header-anchor >Development Benefits</a></h2> <p>In addition to the more composable code for the end-user, the package itself has been able to be simplified. Compared to Yields.jl, the lines of source code have been reduced by 30&#37; while the number of lines of documentation has increased by over 20&#37;.</p> <h2 id=migration_guide ><a href="#migration_guide" class=header-anchor >Migration Guide</a></h2> <p>For those looking to upgrade from Yields &#40;v3.x.x&#41; to FinanceModels &#40;v4&#43;&#41;, there is a <a href="https://juliaactuary.github.io/FinanceModels.jl/dev/migration/">migration guide here</a>. Associated packages <a href="https://github.com/JuliaActuary/ActuaryUtilities.jl/pull/101#issue-1773044104">ActuaryUtilities.jl</a> and <a href="https://github.com/JuliaActuary/FinanceCore.jl/compare/v1.1.0...v2.0.0">FinanceCore.jl</a> had major version releases for minor breaking changes where most code should remain unaffected &#40;FinanceCore is not intended to be user-facing&#41;.</p> <p>Some tutorials or examples on the site may still use Yields.jl - that&#39;s okay as they will still work given Julia&#39;s strong degree of reproducibility and dependency management tools. Please open an issue on the <a href="https://github.com/JuliaActuary/JuliaActuary.org">JuliaActuary.org repository</a> if you have trouble with any of the old example code.</p> <h2 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h2> <p>In this post we&#39;ve now defined two assets that can work seamlessly with projecting cashflows, fitting models, and determining valuations :&#41;</p> <p>FinanceModel.jl should provide the basis for a performant and composable design to facilitate further development and use by actuaries and other financial professionals.</p> <div class=page-foot > The packages in JuliaActuary are open-source and liberally licensed (MIT License) to allow wide private and commercial usage of the packages, like the base Julia language and many other packages in the ecosystem. See <a href="/terms/" >terms of this site.</a> <div class=copyright > &copy; Alec Loudenback. Last modified: August 19, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://julialang.org">Julia</a>. </div> </div></div> <script data-goatcounter="https://juliaactuary.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>