<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta name=Description  content="Practical, extensible, and open-source actuarial modeling and analysis."> <meta property="og:description" content="Practical, extensible, and open-source actuarial modeling and analysis."> <meta property="og:image" content="/assets/logo_square.svg"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <script async defer src="https://buttons.github.io/buttons.js"></script> <title>A tour of the Julia Ecosystem | JuliaActuary</title> <link rel=apple-touch-icon  sizes=180x180  href="/assets/apple-touch-icon.png"> <link rel=icon  type="image/png" sizes=32x32  href="/assets/favicon-32x32.png"> <link rel=icon  type="image/png" sizes=16x16  href="/assets/favicon-16x16.png"> <link rel=manifest  href="/assets/site.webmanifest"> <header> <div class=blog-name > <a href="/"> <div class=blog-name-logo-container > <div class=blog-name-logo > <img src="/assets/logo_square.svg" alt=logo  /> </div> <div>JuliaActuary</div> </div> </a> <div class=tagline >Practical, extensible, and open-source actuarial modeling and analysis. </div> </div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/#packages">Packages</a> <ul> <li><a href="/#mortalitytablesjl">MortalityTables.jl</a> <li><a href="/#actuaryutilitiesjl">ActuaryUtilities.jl</a> <li><a href="/#lifecontingenciesjl">LifeContingencies.jl</a> <li><a href="/#yieldsjl">Yields.jl</a> <li><a href="/#experienceanalysisjl">ExperienceAnalysis.jl</a> </ul> <li><a href="/#community">Community</a> <ul> <li><a href="/#learn">Learn</a> <li><a href="/#integration_with_r_and_python">Integration</a> <li><a href="/#contributing">Contributing</a> </ul> <li><a href="/#blog">Blog</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=fill_title ><a href="#fill_title" class=header-anchor >A tour of the Julia Ecosystem</a></h1> <p><em>By: Alec Loudenback</em></p> <p><em>July 18, 2021</em>7</p> <blockquote> <p><strong>&#33;&#33; Note that this article is a draft</strong></p> </blockquote> <p>The article titled <a href="/blog/julia-actuaries">Julia for Actuaries</a> gave a longer introduction to why Julia works so well in Actuarial Workflows. In summary: Julia&#39;s attribtutes are &quot;evident in its pragmatic, productivity-focused design choices, pleasant syntax, rich ecosystem, thriving communities, and its ability to be both very general purpose and power cutting edge computing&quot;.</p> <p>In the <a href="https://insights.stackoverflow.com/survey/2021?_ga&#61;2.236209345.190202062.1628102352-126161871.1625855113#technology-most-loved-dreaded-and-wanted">2021 Stack Overflow Survey</a>, Julia was the 5th most loved lanuage. This was ahead of other languages commonly used in actuarial contexts, such as Python &#40;6th&#41;, R &#40;28th&#41;, C&#43;&#43; &#40;25th&#41;, Matlab &#40;36th&#41;, or VBA &#40;37th&#41;.</p> <p>This set of articles will introduce three aspects of the Julia ecosystem:</p> <ol> <li><p>Basic tooling and general packages of interest</p> <li><p>Actuarial focused packages</p> </ol> <h2 id=reminder_of_why_julia ><a href="#reminder_of_why_julia" class=header-anchor >Reminder of &quot;why Julia?&quot;</a></h2> <p>There are three main reasons to consider using Julia:</p> <ol> <li><p><strong>The language itself offers expressiveness, pleasant sytax, and less boilerplate than many alternatives.</strong> Multiple dispatch is an evolution of object oriented approaches that&#39;s more amenable to a wide range of programming styles, including functional and vectorizied approaches.</p> <li><p><strong>High performance Julia code, instead of needing libraries written in C/Cython/etc..</strong> For lots of problems, especially &quot;toy&quot; problems as you learn a language, the speed of Matlab/Python/R is fast enough. However, in real usage, particluarly actuarial problems, you might find that when you need the performance it&#39;s too late<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup></p> <li><p><strong>The tooling and ecosystem is very modern, mature, and broad.</strong> A built-in package manager, packages that work together without needing to know about each other, differntiable programming, first-class GPU/parallel support, and wide range of packages relevant &#40;and specialized for&#41; actuarial workloads.</p> </ol> <p>Why Julia works so well in actuarial contexts was discussed in the prior article, <a href="/blog/julia-actuaries">Julia for Actuaries</a>. The rest of this article is going to focus on getting oriented to using Julia, and the next article in the series will introduce acturial packages available.</p> <h2 id=julias_ecosystem ><a href="#julias_ecosystem" class=header-anchor >Julia&#39;s ecosystem</a></h2> <h3 id=basic_tooling ><a href="#basic_tooling" class=header-anchor >Basic Tooling</a></h3> <h4 id=installation ><a href="#installation" class=header-anchor >Installation</a></h4> <p>Julia is open source and can be downloaded from <a href="https://JuliaLang.org">JuliaLang.org</a> and is available for all major operating systems. After you download and install, then you have Julia installed and can access the <strong>REPL</strong>, or Read-Eval-Print-Loop, which can run complete programs or <a href="https://krasjet.com/rnd.wlk/julia/">function as powerful day-to-day calculator</a>. However, many people find it more comfortable to work in a text editor or <strong>IDE</strong> &#40;Integrated Development Environment&#41;.</p> <p>If you want a pre-packaged solution with a curated set of packages, consider the JuliaPro installation available from <a href="https://juliacomputing.com/">Julia Computing</a>, which has optional upgrades for more turn-key enterprise support.</p> <h3 id=package_management ><a href="#package_management" class=header-anchor >Package Management</a></h3> <p>Julia comes with <code>Pkg</code>, a built-in package amanger. With it, you can install packages, pin certain versions, recreate environmnets with the same set of dependencies, and upgrade/remove/develop packages easily. It&#39;s one of the things that <em>just works</em> and makes Julia stand out versus alternative languages that don&#39;t have a de-facto way of managing or installing packages.</p> <p>Package installation is accomplished interatvely in the REPL, or executing commands.</p> <ul> <li><p>In the REPL, you can change to the Package Management Mode by hitting <code>&#93;</code> and, e.g., <code>add DataFrames CSV</code> to install the two packages. Hit backspace to exit that mode in the REPL.</p> <li><p>To execute certain commands, the above would be the same as <code>using Pkg; Pkg.add&#40;&#91;&quot;DataFrames&quot;, &quot;CSV&quot;&#93;&#41;</code></p> </ul> <p>Related to packages, is <strong>environments</strong> which are a self-contained workspace for your code. This lets you install only packages that are relevant to the current work. It also lets you &#39;remember&#39; the exact set of packages and versions that you used. In fact, you can share the environment with others and it will be able to recreate the same environment as when you ran the code. This is accomplished via a <code>Project.toml</code> file, which tracks the direct dependencies you&#39;ve added, along with details about your project like its version number. The <code>Manifest.toml</code> tracks the entire dependency tree.</p> <h4 id=editors ><a href="#editors" class=header-anchor >Editors</a></h4> <p>Because Julia is very extensible and amenable to analysis of its own code, you can typically find plugins for whatever tool you prefer to write code in. I will mention a few here:</p> <h5 id=visual_studio_code ><a href="#visual_studio_code" class=header-anchor >Visual Studio Code</a></h5> <p>Visual Studio Code is a free editor from Microsoft. There&#39;s a full-featured Julia plugin available, which will help with auto-completion, warnings, and other code hints that you might find in a dedicated editor &#40;e.g. PyCharm or RStudio&#41;. Like those tools, you can view plots, show datasets, debug, and manage version control.</p> <h5 id=notebooks ><a href="#notebooks" class=header-anchor >Notebooks</a></h5> <p>Notebooks are typically more interactive environments than text editors - you can write code in cells and see the results side-by-side.</p> <p>The most popular notebook tool is Jupyter &#40;&quot;Julia, Python, R&quot;&#41;. It is widely used and fits in well with exploratory data analysis or other interactive workflows. It can be installed by adding the <a href="https://github.com/JuliaLang/IJulia.jl"><code>IJulia.jl</code></a> package.</p> <p><a href="https://plutojl.org/"><code>Pluto.jl</code></a> is a newer tool, which adds reactivity and interactivity. It is also more amenable to version control than Jupyter notebooks are. Pluto is unique to Julia because of the language&#39;s ability to introspect and analyze dependencies in its own code.</p> <h3 id=the_language_itself ><a href="#the_language_itself" class=header-anchor >The language itself</a></h3> <p>Julia is a high level language, with syntax that should feel familiar to someone coming from R, Python, or Matlab. There&#39;s a ton of great references online, such as:</p> <ul> <li><p><a href="https://cheatsheets.quantecon.org/">Matlab-Python-Julia Cheatsheet</a></p> <li><p><a href="https://learnxinyminutes.com/docs/julia/">Learn Julia in Y minutes</a></p> <li><p><a href="https://docs.julialang.org/en/v1/manual/getting-started/">Julia Official Documenation</a></p> </ul> <p>Julia code is compiled on-the-fly, generating efficient code for the specific data that you are currently working with. This is kind of an in-between of a fully interpreted language &#40;like pure Python or R&#41; and a complied language like C&#43;&#43; which must compile everthing in advance.</p> <p>Born of a desire to have the niceites of high level langagues with the performance of low level compiled code, there are many built-in data structures and functions related to numerical computing like that used in finance, insurance, and statistics.</p> <p>If you want a ground-up introduction, the e-book <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html">Think Julia</a> starts simple and builds up. If you prefer a learn-by-example, the interactive, free, online course <a href="https://computationalthinking.mit.edu/Spring21/">Introduction to Computational Thinking</a> by MIT will have you working on everything from data science to climate modeling.</p> <p>Lastly, <a href="https://juliaacademy.com/">JuliaAcademy.com</a> has a number of free courses that introduce the language via data science, machine learning, or &quot;nervous beginners&quot;.</p> <h3 id=a_whirlwind_tour_of_general-purpose_packages ><a href="#a_whirlwind_tour_of_general-purpose_packages" class=header-anchor >A whirlwind tour of general-purpose packages</a></h3> <p>The Julia ecosystem favors composability and interoperability as an emergent aspect, enabled by multiple dispatch. In other words, because it&#39;s really easy to specialize functionality based on the type of data you are working with, there&#39;s much less need to bundle a lot of features within a single package. As you&#39;ll see, Julia packages tend to be less vertically integrated because its easier to pass data around. Counterexamples of this in Python and R: </p> <ul> <li><p>&quot;numpy&quot; compatible packages that are designed to work with the subset of numerically fast libraries in Python</p> <li><p>special functions in Pandas to read CSV, JSON, database connections, etc. </p> <li><p>The &quot;tidyverse&quot; in R has a tightly coupled set of pacakges that works well together but has limitations with some other R packages</p> </ul> <p>Julia is not perfect in this regard, but it&#39;s really neat to see how frequently things <em>just work</em>. It&#39;s not magic, but because of Julia features outside the scope of this article it&#39;s easy for package developers &#40;and you&#33;&#41; to do this.</p> <p>Julia also has language-level support for documentation, so packages are able to follow a consistent style of help text and have the docs be auto-generated into web pages available online.</p> <p>The following highlighted packages were chosen for their relevance to typical actuarial work, with a bias towards those I&#39;ve personally used am familiar with. This is a small sampling of the over 6000 registered Julia Packages<sup id="fnref:2"><a href="#fndef:2" class=fnref >[2]</a></sup></p> <h4 id=data ><a href="#data" class=header-anchor >Data</a></h4> <p>Starting with getting data in and out of your code, <code>CSV.jl</code> offers top-class read and write performance. <code>ODBC.jl</code> lets you connect to any database.</p> <p><code>DataFrames.jl</code> is a mature package for working with dataframes, comparable to Pandas or dplyr. </p> <p><code>Dates</code> is a built-in package which builds on years of pain-points related to date manipulation into a straightforward and complete interface.</p> <h4 id=plotting ><a href="#plotting" class=header-anchor >Plotting</a></h4> <p><code>Plots.jl</code> isn&#39;t really a plotting tool - more specifically it&#39;s an interface to consistently work with a number of plotting backends, depending if you are trying to emphasize interactivity on the web or print-quality output. You can very easily add animations or change almost any feature of a plot.</p> <p><code>Makie.jl</code> is an up-and-coming package that supports GPU-accelerated plotting and can create very rich, beautful visualizations, but it&#39;s a little less beginner friendly.</p> <h4 id=statistics ><a href="#statistics" class=header-anchor >Statistics</a></h4> <p>Julia has first-class suport for <code>missing</code> values, which follows the rules of <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a> so other pacakges don&#39;t need to do anything special to incorporate missing values.</p> <p><code>StatsBase.jl</code> and <code>Distributions.jl</code> are essentials for a range of statistics functions and probability distributions respectively.</p> <p><code>Turing.jl</code>, a Bayesian Stats library, is outstanding in it&#39;s combination of clear model syntax with performance. <code>GLM.jl</code> is useful for any type of linear modeling.</p> <h4 id=differentiable_progamming ><a href="#differentiable_progamming" class=header-anchor >Differentiable Progamming</a></h4> <p>Sensitivity testing is very common in actuarial workflows, but essentially it&#39;s often gettnig at understanding the change in one variable in relation to another. In other words, the derivative&#33;</p> <p>Julia has unique capabilities where almost across the entire language and ecosystem, you can take the derivate of entire functions or scripts. For example, the following is real Julia code to automatically calculate the sensitvity of the ending account value with respect to the inputs:</p> <pre><code class=language-julia-repl >julia&gt; using Zygote

julia&gt; function policy_av&#40;pol&#41;
	COIs &#61; &#91;0.00319,0.00345,0.0038,0.00419,0.0047,0.00532&#93;
	av &#61; 0.0
	for &#40;i,coi&#41; in enumerate&#40;COIs&#41;
		av &#43;&#61; av * &#40;pol.credit_rate&#41;
		av &#43;&#61; pol.annual_premium
		av -&#61; &#40;pol.face&#41; * coi
	end
	return av                # return the final account value
end

julia&gt; pol&#61; &#40;annual_premium &#61; 1000, face &#61; 100_000, credit_rate &#61; 0.05&#41;;

julia&gt; policy_av&#40;pol&#41;        # the ending account value
4048.08

julia&gt; policy_av&#39;&#40;pol&#41;       # the derivative of the account value with respect to the inputs
&#40;annual_premium &#61; 6.802, face &#61; -0.0275, credit_rate &#61; 10972.52&#41;</code></pre> <p>When executing the code above, Julia isn&#39;t just adding a small amount and calculating the finite difference. Differentiation can be applied to entire programs through extensive use of basic derivatives and the chain rule. This concept, <strong>automatic differentiation</strong>, has a lot potential uses in optimization, machine learning, sensitivty testing, and risk analysis.</p> <h4 id=machine_learning ><a href="#machine_learning" class=header-anchor >Machine Learning</a></h4> <p><code>Flux.jl</code>, <code>Gen.jl</code>, <code>Knet</code>, and <code>MLJ</code> are all very populare machine learning libraries. Many of these libraries take advantage of the automatic differentiaion mentioned above. There are also packages for PyTorch, Tensorflow, and SciKitML available.</p> <h4 id=utilities ><a href="#utilities" class=header-anchor >Utilities</a></h4> <p>There are also a lot of nice quality-of-life packages, like <code>Revise.jl</code> which lets you edit code on the fly without needing to re-run entire scripts.</p> <p><code>BenchmarkTools.jl</code> makes it incredibly easy to benchmark your code - simply add <code>@benchmark</code> in front of what you want to test and you will be presented with detailed statistics. For example:</p> <pre><code class=language-julia >julia&gt; @benchmark present_value&#40;0.05,&#91;10,10,10&#93;&#41;

BenchmarkTools.Trial: 10000 samples with 994 evaluations.
 Range &#40;min … max&#41;:  33.492 ns … 829.015 ns  ┊ GC &#40;min … max&#41;: 0.00&#37; … 95.40&#37;
 Time  &#40;median&#41;:     34.708 ns               ┊ GC &#40;median&#41;:    0.00&#37;
 Time  &#40;mean ± σ&#41;:   36.599 ns ±  33.686 ns  ┊ GC &#40;mean ± σ&#41;:  4.40&#37; ±  4.55&#37;

  ▁▃▆▆▆██▇▄▃▂         ▁                                        ▂
  █████████████▆▆▇█▇████▇██▇█▇█▇▇▆▆▅▅▅▅▅▄▅▄▄▅▅▅▅▄▄▁▅▄▄▅▄▄▅▅▆▅▆ █
  33.5 ns       Histogram: log&#40;frequency&#41; by time      45.6 ns &lt;

 Memory estimate: 112 bytes, allocs estimate: 1.</code></pre> <p><code>Test</code> is a built-in package for performing testsets, while <code>Documenter</code> will build high-quality documentation based on your inline documentation.</p> <p><code>ClipData.jl</code> lets you copy and paste from spreadhseets to Julia sessions.</p> <h4 id=other_packages ><a href="#other_packages" class=header-anchor >Other packages</a></h4> <p>Julia is a general purpose language, so you will find packages for web development, graphics, game development, audio production, and much more.</p> <h3 id=acturial_packages ><a href="#acturial_packages" class=header-anchor >Acturial packages</a></h3> <p>Saving the best for last, the next article in the series will dive deeper into actuarial packages, such as those published by <a href="https://JuliaActuary.org">JuliaActaury</a> for easy mortality table manipulation, common actuarial functions, financial math, and experience analysis.</p> <div class=footnote  id=footnote-1 ><p class=footnote-title >1</p><p>https://ocw.mit.edu/courses/mathematics/18-335j-introduction-to-numerical-methods-spring-2019/week-1/Julia-intro.pdf</p> </div> <table class=fndef  id="fndef:2"> <tr> <td class=fndef-backref ><a href="#fnref:2">[2]</a> <td class=fndef-content >As of July 2021. </table> <div class=page-foot > <div class=copyright > &copy; Alec Loudenback. Last modified: August 15, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://julialang.org" >Julia</a>. </div> </div> </div> <script src="/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script> <script data-goatcounter="https://juliaactuary.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>