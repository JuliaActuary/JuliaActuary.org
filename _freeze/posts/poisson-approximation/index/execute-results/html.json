{
  "hash": "7ab031145039d1795a0f613d1fabad37",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Poisson approximation to Binomial\"\ncategories: [modeling,statistics,experience-analysis]\n---\n\n\n\n\nThis notebook explores using the Poissson approximation to the Binomial. This can be useful for a number of reasons:\n\n1. The Binomial probability mass formula becomes more unwieldy for large ``N`` faster than it does for the Poisson.\n2. In actuarial, and other contexts, ``N`` can be a non-integer value (think partial period exposures) and rounding up or down could materially distort the posterior estimate if ``N`` is small.\n\nWe will look at the approximation across a range of parameters ``q`` (the probabilty a binomial event occurs) and ``N`` (the number of chances for the event to occur, or \"exposures\"). \n\nUnder certain conditions, the Poisson distribution can approximate the Binomial, where the average number of events, ``λ=N*q``.\n\nWhat are those conditions? [According to Wikipedia](https://en.wikipedia.org/wiki/Binomial_distribution#Poisson_approximation): \n\n> According to two rules of thumb, this approximation is good if n ≥ 20 and p ≤ 0.05, or if n ≥ 100 and np ≤ 10.\n\nIt's not really that simple, and arguably a bit restrictive as this analysis will show.\n\n## Approach\n\nWe will use Julia and Turing.jl to simulate the posterior distribution. Our prior for the parameter \\$q\\$ will be \\${Uniform} = Beta(1,1)\\$.\n\nWe will sample from the posterior using the No-U-Turn (NUTS) sampler, and aggregate the results of the chains over $(trials) trials of simulated outcomes for the given \\$q\\$ and \\$N\\$.\n\nThis is overkill for a toy problem where we could just model the parameters themselves, but it demonstrates using Bayesian MCMC techniques in a simple, exploratory fashion.\n\nWe begin by importing the relevant packages:\n\n::: {#2ee86681 .cell execution_count=1}\n``` {.julia .cell-code}\nusing Turing\nusing CairoMakie\nusing StatsBase\nusing MCMCChains\nusing DataFrames\nusing ThreadsX\nusing Logging\nusing Markdown\n```\n:::\n\n\n\"\"\"\n\n## Define the Models\n\n::: {#24f53e59 .cell execution_count=2}\n``` {.julia .cell-code}\n@model function poisson(N,n_events) \n\tq ~ Beta(1,1)\n\t\n\tn_events ~ Poisson(q*N)\nend\n\n@model function binom(N,n_events) \n\tq ~ Beta(1,1)\n\t\n\tn_events ~ Binomial(N,q)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nbinom (generic function with 2 methods)\n```\n:::\n:::\n\n\n## Simulation Parameters\n\n::: {#6b43a494 .cell execution_count=3}\n``` {.julia .cell-code}\ntrials = 30\n\n# true probabilities\nqs = [0.05,0.25,0.5,0.75,0.95]\n\n# number of observations\nNs = [10,25,50,100,250,500,1000,5000]\n\n# combine q and N into joint model points\nmodel_points =  [(;q,N) for q in qs, N in Ns]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n5×8 Matrix{@NamedTuple{q::Float64, N::Int64}}:\n (q = 0.05, N = 10)  (q = 0.05, N = 25)  …  (q = 0.05, N = 5000)\n (q = 0.25, N = 10)  (q = 0.25, N = 25)     (q = 0.25, N = 5000)\n (q = 0.5, N = 10)   (q = 0.5, N = 25)      (q = 0.5, N = 5000)\n (q = 0.75, N = 10)  (q = 0.75, N = 25)     (q = 0.75, N = 5000)\n (q = 0.95, N = 10)  (q = 0.95, N = 25)     (q = 0.95, N = 5000)\n```\n:::\n:::\n\n\n## Sample from the Posterior\n\n\nThis is a collection of samples (chains) from Markov chains that are sampled in proportion to the posterior density. If this is new to you, I highly recommend the book *Statistical Rethinking*:\n\n::: {#952da15e .cell execution_count=4}\n``` {.julia .cell-code}\nLogging.disable_logging(Logging.Warn); #Disable warning logs to improve sampling time\n\nbpchains = map(model_points) do mp\n\t\n    ThreadsX.map(1:trials) do i\n        claims = sum(rand() < mp.q for _ in 1:mp.N)\n        bc = sample(binom(mp.N,claims), NUTS(), 500)\n        pc = sample(poisson(mp.N,claims), NUTS(), 500)\n\n        (;bc,pc)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n5×8 Matrix{Vector{@NamedTuple{bc::Chains{Float64, AxisArrays.AxisArray{Float64, 3, Array{Float64, 3}, Tuple{AxisArrays.Axis{:iter, StepRange{Int64, Int64}}, AxisArrays.Axis{:var, Vector{Symbol}}, AxisArrays.Axis{:chain, UnitRange{Int64}}}}, Missing, @NamedTuple{parameters::Vector{Symbol}, internals::Vector{Symbol}}, @NamedTuple{varname_to_symbol::OrderedDict{AbstractPPL.VarName, Symbol}, start_time::Float64, stop_time::Float64}}, pc::Chains{Float64, AxisArrays.AxisArray{Float64, 3, Array{Float64, 3}, Tuple{AxisArrays.Axis{:iter, StepRange{Int64, Int64}}, AxisArrays.Axis{:var, Vector{Symbol}}, AxisArrays.Axis{:chain, UnitRange{Int64}}}}, Missing, @NamedTuple{parameters::Vector{Symbol}, internals::Vector{Symbol}}, @NamedTuple{varname_to_symbol::OrderedDict{AbstractPPL.VarName, Symbol}, start_time::Float64, stop_time::Float64}}}}}:\n [(bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))  …  (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))]  …  [(bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))  …  (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))]\n [(bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))  …  (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))]     [(bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))  …  (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))]\n [(bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))  …  (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))]     [(bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))  …  (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))]\n [(bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))  …  (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))]     [(bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))  …  (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))]\n [(bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))  …  (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))]     [(bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))  …  (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3})), (bc = MCMC chain (500×13×1 Array{Float64, 3}), pc = MCMC chain (500×13×1 Array{Float64, 3}))]\n```\n:::\n:::\n\n\n## Results\n\nThe results indicate that the Poisson is a good fit when \\$q\\$ is small, where \"small\" depends on N, but in general it seems to provide a good fit in less restrictive cases than the \"rule of thumb\" quoted below. E.g. go ahead and use the Poisson approximation when you've got enough expsoures even if \\$q\\$ is well above \\$0.10\\$. The Poisson approximation also isn't terrible when \\$N\\$ is as low as 10 as long as \\$q\\$ is very small (e.g.  \\$<0.05\\$ ).\n\nThe fit remains poor when \\$q >> 0.5\\$ and when \\$N\\$ is small.\n\n### Visualization\n\nThis visualization shows the aggregated posterior distribution across all of the trials and model points. The darker shaded band indicates the middle 50% of the posterior:\n\n::: {#c38058ab .cell execution_count=5}\n``` {.julia .cell-code}\nfunction plot_band_under!(ax,plot,y,low,high,label=\"\")\n    function points(plot)\n        pts = plot.plots[2].converted[1][]\n        [p[1] for p in pts], [p[2] for p in pts]\n    end    \n    xs′, ys′ = points(plot)\n\n    filt = findall(x-> (x ≥ low) && (x ≤ high),xs′)\n    typeof(xs′[filt]), typeof(fill(y,length(filt))), typeof(ys′[filt])\n    b = band!(\n        ax,\n        Float64.(xs′[filt]), \n        Float64.(fill(y * 1.0, length(filt))), \n        Float64.(ys′[filt]),\n        color=(plot.color.val, 0.9),transparency=true,shading = false) # 0.25 alpha\n    translate!(b,0,0,5)\nend\n\n\nlet\n    f = Figure(resolution=(1280,960))\n    a = Any # outer variable to set as axis for to grab legend\n    \n    for (i,N) in enumerate(reverse(Ns))\n        ax = Axis(f[i+1,1:10],\n        xticks=qs,\n        ylabel=\"N=$N\"\n        )\n        a = ax\n        xlims!(0,1)\n        model_idx = findall(x->x.N == N,model_points)\n\n        for n in model_idx\n            c = bpchains[n]\n            q = model_points[n].q\n            y = model_points[n].N\n            bpoints = vcat([x.bc[\"q\"][:] for x in c]...)\n            ppoints = vcat([x.pc[\"q\"][:] for x in c]...)\n            bqtls = quantile(bpoints,[.25,.75])\n            pqtls = quantile(ppoints,[.25,.75])\n            j = density!(\n\t\t\t\tbpoints,\n\t\t\t\t# linewidth=10,\n\t\t\t\tstrokewidth = 1, \n\t\t\t\tstrokecolor = (:grey30,0.6),\n\t\t\t\tlabel=\"Binomial\",\n            \tcolor=(:red,.25),\n            )\n            plot_band_under!(ax,j,0,bqtls[1],bqtls[2],\"Binomial\")\n        \n\n            j = density!(\n\t\t\t\tppoints, \n\t\t\t\tcolor=(:blue,.25),\n\t\t\t\t# linewidth=10,\n\t\t\t\tstrokewidth = 1, \n\t\t\t\tstrokecolor = (:grey30,0.6),\n\t\t\t\tlabel=\"Poisson\",\n\t\t\t)\n            plot_band_under!(ax,j,0,pqtls[1],pqtls[2],\"Poisson\")\n\n            hideydecorations!(ax,label=false)\n        end\n\n        scatter!(\n            qs,\n            zeros(length(qs)),\n            marker = :vline,\n            markersize=20,\n            color=:grey30,\n            label=\"actual value\"\n            )\n    end\n\n    Legend(f[1,5],a,unique=true,orientation=:horizontal)\n    f\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](index_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}