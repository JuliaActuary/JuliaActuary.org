{
  "hash": "a6a838d9c0c6094e995a8ce81900f118",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Stochastic claims projections demo\"\ncategories: [modeling,benchmark, tutorial]\n---\n\n\n\n::: {#55653df9 .cell execution_count=2}\n``` {.julia .cell-code}\nusing CSV, DataFrames\nusing MortalityTables, ActuaryUtilities\nusing Dates\nusing ThreadsX\nusing BenchmarkTools\nusing CairoMakie\nusing Random\n```\n:::\n\n\nDefine a datatype. Not strictly necessary, but will make extending the program with more functions easier.\n\nType annotations are optional, but providing them is able to coerce the values to be all plain bits (i.e. simple, non-referenced values like arrays are) when the type is constructed. This makes the whole data be stored in the stack and is an example of data-oriented design. It's much slower without the type annotations (~0.5 million policies per second, ~50x slower).\n\n::: {#c5b3d3fd .cell execution_count=3}\n``` {.julia .cell-code}\n@enum Sex Female = 1 Male = 2\n@enum Risk Standard = 1 Preferred = 2\n\nstruct Policy\n    id::Int\n    sex::Sex\n    benefit_base::Float64\n    COLA::Float64\n    mode::Int\n    issue_date::Date\n    issue_age::Int\n    risk::Risk\nend\n```\n:::\n\n\nLoad the data:\n\n::: {#c4803f9b .cell execution_count=4}\n``` {.julia .cell-code}\nsample_csv_data =\n    IOBuffer(\n        raw\"id,sex,benefit_base,COLA,mode,issue_date,issue_age,risk\n         1,M,100000.0,0.03,12,1999-12-05,30,Std\n         2,F,200000.0,0.03,12,1999-12-05,30,Pref\"\n    )\n\npolicies = let\n\n    # read CSV directly into a dataframe\n    # df = CSV.read(\"sample_inforce.csv\",DataFrame) # use local string for notebook\n    df = CSV.read(sample_csv_data, DataFrame)\n\n    # map over each row and construct an array of Policy objects\n    map(eachrow(df)) do row\n        Policy(\n            row.id,\n            row.sex == \"M\" ? Male : Female,\n            row.benefit_base,\n            row.COLA,\n            row.mode,\n            row.issue_date,\n            row.issue_age,\n            row.risk == \"Std\" ? Standard : Preferred,\n        )\n    end\n\n\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n2-element Vector{Policy}:\n Policy(1, Male, 100000.0, 0.03, 12, Date(\"1999-12-05\"), 30, Standard)\n Policy(2, Female, 200000.0, 0.03, 12, Date(\"1999-12-05\"), 30, Preferred)\n```\n:::\n:::\n\n\nDefine what mortality gets used:\n\n::: {#13dd1f58 .cell execution_count=5}\n``` {.julia .cell-code}\nmort = Dict(\n    Male => MortalityTables.table(988).ultimate,\n    Female => MortalityTables.table(992).ultimate,\n)\n\nfunction mortality(pol::Policy, params)\n    return params.mortality[pol.sex]\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nmortality (generic function with 1 method)\n```\n:::\n:::\n\n\nThis defines the core logic of the policy projection and will write the results to the given `out` container (here, a named tuple of arrays).\n\nThis is using a threaded approach where it could be operating on any of the computer's available threads, thus acheiving thread-based parallelism (as opposed to multi-processor (multi-machine) or GPU-based computation which requires formulating the problem a bit differently (array/matrix based). For the scale of computation here, I think I'd apply this model of parallelism.\n\n::: {#2477e1e8 .cell execution_count=6}\n``` {.julia .cell-code}\nfunction pol_project!(out, policy, params)\n    # some starting values for the given policy\n    dur = duration(policy.issue_date, params.val_date)\n    start_age = policy.issue_age + dur - 1\n    COLA_factor = (1 + policy.COLA)\n    cur_benefit = policy.benefit_base * COLA_factor^(dur - 1)\n\n    # get the right mortality vector\n    qs = mortality(policy, params)\n\n    # grab the current thread's id to write to results container without conflicting with other threads\n    tid = Threads.threadid()\n\n    ω = lastindex(qs)\n\n    # inbounds turns off bounds-checking, which makes hot loops faster but first write loop without it to ensure you don't create an error (will crash if you have the error without bounds checking)\n    @inbounds for t in 1:min(params.proj_length, ω - start_age)\n\n        q = qs[start_age+t] # get current mortality\n\n        if (rand() < q)\n            return # if dead then just return and don't increment the results anymore\n        else\n            # pay benefit, add a life to the output count, and increment the benefit for next year\n            out.benefits[t, tid] += cur_benefit\n            out.lives[t, tid] += 1\n            cur_benefit *= COLA_factor\n        end\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\npol_project! (generic function with 1 method)\n```\n:::\n:::\n\n\nParameters for our projection:\n\n::: {#aab92737 .cell execution_count=7}\n``` {.julia .cell-code}\nparams = (\n    val_date=Date(2021, 12, 31),\n    proj_length=100,\n    mortality=mort,\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n(val_date = Date(\"2021-12-31\"), proj_length = 100, mortality = Dict{Sex, OffsetArrays.OffsetVector{Float64, Vector{Float64}}}(Male => [0.022571, 0.022571, 0.022571, 0.022571, 0.022571, 0.022571, 0.022571, 0.022571, 0.022571, 0.022571  …  0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4], Female => [0.00745, 0.00745, 0.00745, 0.00745, 0.00745, 0.00745, 0.00745, 0.00745, 0.00745, 0.00745  …  0.376246, 0.386015, 0.393507, 0.398308, 0.4, 0.4, 0.4, 0.4, 0.4, 1.0]))\n```\n:::\n:::\n\n\nCheck the number of threads we're using:\n\n::: {#4b01096f .cell execution_count=8}\n``` {.julia .cell-code}\nThreads.nthreads()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n4\n```\n:::\n:::\n\n\n::: {#1ee7413d .cell execution_count=9}\n``` {.julia .cell-code}\nfunction project(policies, params)\n    threads = Threads.nthreads()\n    benefits = zeros(params.proj_length, threads)\n    lives = zeros(Int, params.proj_length, threads)\n    out = (; benefits, lives)\n    ThreadsX.foreach(policies) do pol\n        pol_project!(out, pol, params)\n    end\n    map(x -> vec(reduce(+, x, dims=2)), out)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nproject (generic function with 1 method)\n```\n:::\n:::\n\n\nExample of single projection:\n\n::: {#6cdd868e .cell execution_count=10}\n``` {.julia .cell-code}\nproject(repeat(policies, 100_000), params)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n(benefits = [5.632041071730104e10, 5.673784917378363e10, 5.7095494627022224e10, 5.739296558536684e10, 5.765668319695172e10, 5.785147298991435e10, 5.79964498594893e10, 5.806223921979738e10, 5.809264362799425e10, 5.8029114887314896e10  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [195316, 190438, 185423, 180374, 175350, 170235, 165130, 159991, 154877, 149681  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n```\n:::\n:::\n\n\n## Benchmarking\n\nUsing a Macbook Air M3 laptop, about 45 million policies able to be stochastically projected per second:\n\n::: {#7dd888f0 .cell execution_count=11}\n``` {.julia .cell-code}\npolicies_to_benchmark = 45_000_000\n# adjust the `repeat` depending on how many policies are already in the array\n# to match the target number for the benchmark\nn = policies_to_benchmark ÷ length(policies)\n\n@benchmark project(p, r) setup = (p = repeat($policies, $n); r = $params)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>BenchmarkTools.Trial: 4 samples with 1 evaluation.\n Range <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-cyan-fg ansi-bold\">min</span> … <span class=\"ansi-magenta-fg\">max</span><span class=\"ansi-bright-black-fg\">):  </span><span class=\"ansi-cyan-fg ansi-bold\">1.075 s</span> … <span class=\"ansi-magenta-fg\">  1.161 s</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>min … max<span class=\"ansi-bright-black-fg\">): </span>0.00% … 0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-blue-fg ansi-bold\">median</span><span class=\"ansi-bright-black-fg\">):     </span><span class=\"ansi-blue-fg ansi-bold\">1.083 s              </span><span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>median<span class=\"ansi-bright-black-fg\">):    </span>0.00%\n Time  <span class=\"ansi-bright-black-fg\">(</span><span class=\"ansi-green-fg ansi-bold\">mean</span> ± <span class=\"ansi-green-fg\">σ</span><span class=\"ansi-bright-black-fg\">):   </span><span class=\"ansi-green-fg ansi-bold\">1.101 s</span> ± <span class=\"ansi-green-fg\">40.427 ms</span>  <span class=\"ansi-bright-black-fg\">┊</span> GC <span class=\"ansi-bright-black-fg\">(</span>mean ± σ<span class=\"ansi-bright-black-fg\">):  </span>0.00% ± 0.00%\n  █ <span class=\"ansi-blue-fg\">█</span>     █        <span class=\"ansi-green-fg\"> </span>                                      █  \n  █▁<span class=\"ansi-blue-fg\">█</span>▁▁▁▁▁█▁▁▁▁▁▁▁▁<span class=\"ansi-green-fg\">▁</span>▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  1.07 s<span class=\"ansi-bright-black-fg\">         Histogram: frequency by time</span>        1.16 s <span class=\"ansi-bold\">&lt;</span>\n Memory estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">29.27 KiB</span>, allocs estimate<span class=\"ansi-bright-black-fg\">: </span><span class=\"ansi-yellow-fg\">227</span>.</pre>\n```\n:::\n\n:::\n:::\n\n\n## Stochastic Ensemble\n\nLoop through and calculate the reults `n` times (this is only running the two policies in the sample data\" `n` times).\n\n::: {#984ad37e .cell execution_count=12}\n``` {.julia .cell-code}\nfunction stochastic_proj(policies, params, n)\n\n    ThreadsX.map(1:n) do i\n        project(policies, params)\n    end\nend\n\nstoch = stochastic_proj(policies, params, 1000)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n1000-element Vector{@NamedTuple{benefits::Vector{Float64}, lives::Vector{Int64}}}:\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 471313.1012018761, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 444257.8011140316, 457585.53514745255, 471313.1012018761, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [383220.68177215644, 394717.3022253211, 406558.82129208074, 418755.5859308432, 431318.2535087685, 444257.8011140316, 457585.53514745255, 471313.1012018761, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 406558.82129208074, 418755.5859308432, 431318.2535087685, 444257.8011140316, 457585.53514745255, 471313.1012018761, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 1, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 394717.3022253211, 406558.82129208074, 418755.5859308432, 431318.2535087685, 444257.8011140316, 457585.53514745255, 471313.1012018761, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n ⋮\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 406558.82129208074, 418755.5859308432, 431318.2535087685, 444257.8011140316, 457585.53514745255, 471313.1012018761, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 1, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 418755.5859308432, 431318.2535087685, 444257.8011140316, 457585.53514745255, 471313.1012018761, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 471313.1012018761, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 394717.3022253211, 406558.82129208074, 418755.5859308432, 431318.2535087685, 444257.8011140316, 457585.53514745255, 471313.1012018761, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 418755.5859308432, 431318.2535087685, 444257.8011140316, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 1, 1, 1, 0, 0, 0, 0  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [383220.68177215644, 394717.3022253211, 406558.82129208074, 418755.5859308432, 431318.2535087685, 444257.8011140316, 457585.53514745255, 471313.1012018761, 485452.49423793243, 500016.0690650704  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 197358.65111266056, 203279.41064604037, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 1, 1, 0, 0, 0, 0, 0, 0, 0  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n (benefits = [574831.0226582347, 592075.9533379817, 609838.2319381211, 628133.3788962648, 646977.3802631528, 666386.7016710474, 686378.3027211789, 706969.6518028142, 728178.7413568987, 750024.1035976056  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], lives = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n```\n:::\n:::\n\n\n::: {#6711eb2e .cell execution_count=13}\n``` {.julia .cell-code}\nv = [pv(0.03, s.benefits) for s in stoch]\nhist(v,\n    bins=15;\n    axis=(xlabel=\"Present Value\", ylabel=\"# scenarios\")\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Warning: Found `resolution` in the theme when creating a `Scene`. The `resolution` keyword for `Scene`s and `Figure`s has been deprecated. Use `Figure(; size = ...` or `Scene(; size = ...)` instead, which better reflects that this is a unitless size and not a pixel resolution. The key could also come from `set_theme!` calls or related theming functions.\n└ @ Makie ~/.julia/packages/Makie/We6MY/src/scenes.jl:227\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=14}\n![](index_files/figure-html/cell-14-output-2.svg){}\n:::\n:::\n\n\n## Further Optimization\n\nIn no particular order:\n\n- the RNG could be made faster: https://bkamins.github.io/julialang/2020/11/20/rand.html\n- Could make the stochastic set distributed, but at the current speed the overhead of distributed computing is probably more time than it would save. Same thing with GPU projections\n- ...\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}