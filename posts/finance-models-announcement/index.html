<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Alec Loudenback">
<meta name="dcterms.date" content="2023-08-19">
<meta name="description" content="JuliaActuary is an ecosystem of packages that makes Julia the easiest language to get started for actuarial workflows.">

<title>JuliaActuary – FinanceModels.jl - Evolving the JuliaActuary Ecosystem</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="stylesheet" href="../../assets/highlight/styles/github.min.css">
<script src="../../assets/highlight/highlight.min.js"></script>
<script src="../../assets/highlight/languages/julia.min.js"></script>
<script src="../../assets/highlight/languages/julia-repl.min.js"></script>
<script src="../../assets/highlight/languages/python.min.js"></script>
<script src="../../assets/highlight/languages/r.min.js"></script>
<script>hljs.highlightAll();</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../assets/logos/android-chrome-512x512.png" alt="JuliaActuary Logo" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">JuliaActuary</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../packages.html"> 
<span class="menu-text">Packages</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../learn.html"> 
<span class="menu-text">Learn</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../examples.html"> 
<span class="menu-text">Examples</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../benchmarks.html"> 
<span class="menu-text">Benchmarks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../community.html"> 
<span class="menu-text">Learn</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/JuliaActuary"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">FinanceModels.jl - Evolving the JuliaActuary Ecosystem</h1>
                  <div>
        <div class="description">
          JuliaActuary is an ecosystem of packages that makes Julia the easiest language to get started for actuarial workflows.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">code</div>
                <div class="quarto-category">blog</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Alec Loudenback </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 19, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Yields.jl has evolved into FinanceModels.jl. The benefits are:</p>
<ul>
<li>Provide a composable set of <strong>contracts</strong> and <strong><code>Quotes</code></strong></li>
<li>Those contracts, when combined with a <strong>model</strong> produce a <strong><code>Cashflow</code></strong> via a flexibly defined <code>Projection</code></li>
<li><strong>models</strong> can be <code>fit</code> with a new unified API: <code>fit(model_type,quotes,fit_method)</code></li>
</ul>
<p>This blog post describes the conceptual overview and motivation for the change.</p>
<section id="finance-models-overview" class="level2">
<h2 class="anchored" data-anchor-id="finance-models-overview">Finance Models Overview</h2>
<p><strong>FinanceModels.jl</strong> provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../assets/relations.png" class="img-fluid figure-img"></p>
<figcaption>A conceptual sketch of FinanceModels.jl</figcaption>
</figure>
</div>
</section>
<section id="cashflow---a-fundamental-financial-type" class="level2">
<h2 class="anchored" data-anchor-id="cashflow---a-fundamental-financial-type">1. <code>Cashflow</code> - a fundamental financial type</h2>
<p>Say you wanted to model a contract that paid quarterly payments, and those payments occurred starting 15 days from the valuation date (first payment time = 15/365 = 0.057)</p>
<p>Previously, you had two options:</p>
<ol type="1">
<li>Choose a discrete timestep to model (e.g.&nbsp;monthly, quarterly, annual) and then lump the cashflows into those timesteps. E.g. with monthly timesteps of a unit payment of our contract, it might look like: <code>[1,0,0,1,0,0...]</code></li>
<li>Keep track of two vectors: one for the payment and one for the times. In this case, that might look like: <code>cfs = [1,1,...];</code>times = <code>[0.057, 0.307...]</code></li>
</ol>
<p>The former has inaccuracies due to the simplified timing and logical complication related to mapping the contracts natural periodicity into an arbitrary modeling choice. The latter becomes unwieldy and fails to take advantage of Julia’s type system.</p>
<p>The new solution: <code>Cashflow</code>s. Our example above would become: <code>[Cashflow(1,0.057), Cashflow(1,0.307),...]</code></p>
</section>
<section id="contracts---a-composable-way-to-represent-financial-instruments" class="level2">
<h2 class="anchored" data-anchor-id="contracts---a-composable-way-to-represent-financial-instruments">2. <strong>Contracts</strong> - A composable way to represent financial instruments</h2>
<p>Contracts are a composable way to represent financial instruments. They are, in essence, anything that is a collection of cashflows. Contracts can be combined to represent more complex instruments. For example, a bond can be represented as a collection of cashflows that correspond to the coupon payments and the principal repayment.</p>
<p>Examples:</p>
<ul>
<li>a <code>Cashflow</code></li>
<li><code>Bond</code>s:
<ul>
<li><code>Bond.Fixed</code>, <code>Bond.Floating</code></li>
</ul></li>
<li><code>Option</code>s:
<ul>
<li><code>Option.EuroCall</code> and <code>Option.EuroPut</code></li>
</ul></li>
<li>Compositional contracts:
<ul>
<li><code>Forward</code>to represent an instrument that is relative to a forward point in time.</li>
<li><code>Composite</code> to represent the combination of two other instruments.</li>
</ul></li>
</ul>
<p>In the future, this notion may be extended to liabilities (e.g.&nbsp;insurance policies in LifeContingencies.jl)</p>
<section id="creating-a-new-contract" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-new-contract">Creating a new Contract</h3>
<p>A contract is anything that creates a vector of <code>Cashflow</code>s when <code>collect</code>ed.&nbsp;For example, let’s create a bond which only pays down principle and offers no coupons.</p>
<pre class="julia"><code>using FinanceModels,FinanceCore

# Transducers is used to provide a more powerful, composable way to construct collections than the basic iteration interface
using Transducers: __foldl__, @next, complete

"""
A bond which pays down its par (one unit) in equal payments. 
"""
struct PrincipalOnlyBond{F&lt;:FinanceCore.Frequency} &lt;: FinanceModels.Bond.AbstractBond
    frequency::F
    maturity::Float64
end

# We extend the interface to say what should happen as the bond is projected
# There's two parts to customize:
# 1. any initialization or state to keep track of
# 2. The loop where we decide what gets returned at each timestep
function Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C&lt;:PrincipalOnlyBond,M,K}
    # initialization stuff
    b = p.contract # the contract within a projection
    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity
    pmt = 1 / length(ts)

    for t in ts
        # the loop which returns a value
        cf = Cashflow(pmt, t)
        val = @next(rf, val, cf) # the value to return is the last argument
    end
    return complete(rf, val)
end</code></pre>
<p>That’s it! then we can use this contract to fitting models, create projections, quotes, etc. Here we simply collect the bond into an array of cashflows:</p>
<pre class="julia-repl"><code>julia&gt; PrincipalOnlyBond(Periodic(2),5.) |&gt; collect
10-element Vector{Cashflow{Float64, Float64}}:
 Cashflow{Float64, Float64}(0.1, 0.5)
 Cashflow{Float64, Float64}(0.1, 1.0)
 Cashflow{Float64, Float64}(0.1, 1.5)
 Cashflow{Float64, Float64}(0.1, 2.0)
 Cashflow{Float64, Float64}(0.1, 2.5)
 Cashflow{Float64, Float64}(0.1, 3.0)
 Cashflow{Float64, Float64}(0.1, 3.5)
 Cashflow{Float64, Float64}(0.1, 4.0)
 Cashflow{Float64, Float64}(0.1, 4.5)
 Cashflow{Float64, Float64}(0.1, 5.0)</code></pre>
<p>Note that all contracts in FinanceModels.jl are currently <em>unit</em> contracts in that they assume a unit par value. Scale assets down to unit values before constructing the default contracts.</p>
<section id="more-complex-contracts" class="level4">
<h4 class="anchored" data-anchor-id="more-complex-contracts">More complex Contracts</h4>
<p><strong>When the cashflow depends on a model</strong>. An example of this is a floating bond where the coupon paid depends on a view of forward rates. See <strong>Section 6 - Projections</strong> for how this is handled.</p>
</section>
</section>
</section>
<section id="quotes---the-observed-price-we-need-to-fit-a-model-to" class="level2">
<h2 class="anchored" data-anchor-id="quotes---the-observed-price-we-need-to-fit-a-model-to">3. <code>Quote</code>s - The observed price we need to fit a model to</h2>
<p>Quotes are the observed prices that we need to fit a model to. They represent the market prices of financial instruments, such as bonds or swaps. In the context of the package, a quote is defined as a pair of a contract and a price.</p>
<p>For example, a par yield bond paying a 4% coupon (paid as 2% twice per annum) implies a price at par (i.e.&nbsp;<code>1.0</code>):</p>
<pre class="julia-repl"><code>julia&gt; ParYield(Periodic(0.04,2),10)
Quote{Float64, FinanceModels.Bond.Fixed{Periodic, Float64, Int64}}(
1.0, 
FinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.040000000000000036, Periodic(2), 10))
</code></pre>
<p>A number of convenience functions are included to construct a <code>Quote</code>:</p>
<ul>
<li><code>ZCBPrice</code> and <code>ZCBYield</code></li>
<li><code>ParYield</code></li>
<li><code>CMTYield</code></li>
<li><code>OISYield</code></li>
<li><code>ForwardYields</code></li>
</ul>
</section>
<section id="models---not-just-yield-curves-anymore" class="level2">
<h2 class="anchored" data-anchor-id="models---not-just-yield-curves-anymore">4. <strong>Models</strong> - Not just yield curves anymore</h2>
<ul>
<li><strong>Yield Curves</strong>: all of Yields.jl yield models are included in the initial FinanceModels.jl release</li>
<li><strong>Equities and Options</strong>: The initial release includes <code>BlackScholesMerton</code> option pricing and one can use constant or spline volatility models</li>
<li><strong>Others</strong> more to come in the future</li>
</ul>
<section id="creating-a-new-model" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-new-model">Creating a new model</h3>
<p>Here we’ll do a complete implementation of a yield curve model where the discount rate is approximated by a straight line (often called an AB line from the <code>y=ax+b</code> formula.</p>
<pre class="julia"><code> using FinanceModels, FinanceCore
 using AccessibleOptimization 
 using IntervalSets
 
struct ABDiscountLine{A} &lt;: FinanceModels.Yield.AbstractYieldModel
    a::A
    b::A
end

ABDiscountLine() = ABDiscountLine(0.,0.)

function FinanceCore.discount(m::ABDiscountLine,t)
    #discount rate is approximated by a straight line, floored at 0.0 and capped at 1.0
    clamp(m.a*t + m.b, 0.0,1.0) 
end


# `@optic` indicates what in our model variables needs to be updated (from AccessibleOptimization.jl)
# `-1.0 .. 1.0` says to bound the search from negative to positive one (from IntervalSets.jl)
FinanceModels.__default_optic(m::ABDiscountLine) = OptArgs([
    @optic(_.a) =&gt; -1.0 .. 1.0,
    @optic(_.b) =&gt; -1.0 .. 1.0,
]...)

quotes = ZCBPrice([0.9, 0.8, 0.7,0.6])

m = fit(ABDiscountLine(),quotes)</code></pre>
<p>Now, <code>m</code> is a model like any of the other yield curve models provided and can be used in that context. For example, calculating the price of the bonds contained within our <code>quotes</code> where we indeed recover the prices for our contrived example:</p>
<pre class="julia-repl"><code>julia&gt; map(q -&gt; pv(m,q.instrument),quotes) 
4-element Vector{Float64}:
 0.9
 0.8
 0.7
 0.6</code></pre>
</section>
</section>
<section id="fit---the-standardized-api-for-all-models-quotes-and-methods" class="level2">
<h2 class="anchored" data-anchor-id="fit---the-standardized-api-for-all-models-quotes-and-methods">5. <code>fit</code> - The standardized API for all models, quotes, and methods</h2>
<pre class="plaintext"><code>       Model                                                               Method
          |                                                                   |
    |------------|                                                     |---------------|
fit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())
                    |-------------------------------------------------|
                                              |
                                              Quotes</code></pre>
<ul>
<li><strong>Model</strong> could be <code>Spline.Linear()</code>, <code>Yield.NelsonSiegelSvensson()</code>, <code>Equity.BlackScholesMerton(...)</code>, etc.</li>
<li><strong>Quote</strong> could be <code>CMTYield</code>s, <code>ParYield</code>s, <code>Option.Eurocall</code>, etc.</li>
<li><strong>Method</strong> could be <code>Fit.Loss(x-&gt;x^2)</code>, <code>Fit.Loss(x-&gt;abs(x))</code>, <code>Fit.Bootstrap()</code>, etc.</li>
</ul>
<p>The benefit of this versus the old Yields.jl API is:</p>
<ul>
<li>Without a generic <code>fit</code> method, no obvious way to expose different curve construction methods (e.g.&nbsp;choice of model and method)</li>
<li>The <code>fit</code> is extensible. Users or other packages could define their own Models, Quotes, or Methods and integrate into the JuliaActuary ecosystem.</li>
<li>The <code>fit</code> formulation is very generic: the required methods are minimal to integrate in order to extend the functionality.</li>
</ul>
<section id="customizing-model-fitting" class="level3">
<h3 class="anchored" data-anchor-id="customizing-model-fitting">Customizing model fitting</h3>
<p>Model fitting can be customized:</p>
<ul>
<li>The <strong>loss function</strong> (least squares, absolute difference, etc.) via the third argument to <code>fit</code>:
<ul>
<li>e.g.<code>fit(ABDiscountLine(), quotes, FIt.Loss(x -&gt; abs(x))</code></li>
<li>the default is <code>Fit.Loss(x-&gt;x^2)</code></li>
</ul></li>
<li>the <strong>optimization algorithm</strong> by defining a method <code>FinanceModels.__default_optim__(m::ABDiscountLine) = OptimizationOptimJL.Newton()</code>
<ul>
<li>you may need to change the <code>__default_optic</code> to be unbounded (simply omit the <code>=&gt;</code> and subsequent bounds)</li>
<li>The default is OptimizationMetaheuristics.ECA()</li>
</ul></li>
<li>The <strong>general algorithm</strong> can be customized by creating a new method for fit:</li>
</ul>
<pre class="julia"><code>function FinanceModels.fit(m::ABDiscountLine, quotes, ...)
   # custom code for fitting your model here
end</code></pre>
<ul>
<li>As an example, the splines (<code>Spline.Linear()</code>, <code>Spline.Cubic()</code>,…) are defined to use bootstrap by default: <code>fit(mod0::Spline.BSpline, quotes, method::Fit.Bootstrap)</code></li>
</ul>
</section>
<section id="using-models-without-fitting" class="level3">
<h3 class="anchored" data-anchor-id="using-models-without-fitting">Using models without fitting</h3>
<p>While many of the examples show models being fit to observed prices, you can skip that step in practice if you want to define an assumed valuation model that does not intend to calibrate market prices.</p>
</section>
</section>
<section id="projections" class="level2">
<h2 class="anchored" data-anchor-id="projections">6. <code>Projection</code>s</h2>
<p>A <code>Projection</code> is a generic way to work with various data that you can project forward. For example, getting the series of cashflows associated with a contract.</p>
<p>What is a <code>Projection</code>?</p>
<pre class="julia"><code>struct Projection{C,M,K} &lt;: AbstractProjection
    contract::C    # the contract (or set of contracts) we want to project
    model::M       # the model that defines how the contract will behave
    kind::K           # what kind of projection do we want? only cashflows? 
end</code></pre>
<p><code>contract</code> is obvious, so let’s talk more about the second two:</p>
<ul>
<li><code>model</code> is the same kind of thing we discussed above. Some contracts (e.g.&nbsp;a floating rate bond). We can still decompose a floating rate bond into a set of cashflows, but we need a model.
<ul>
<li>There are also projections which don’t need a model (e.g.&nbsp;fixed bonds) and for that there’s the generic <code>NullModel()</code></li>
</ul></li>
<li><code>kind</code> defines what we’ll return from the projection.
<ul>
<li><code>CashflowProjection()</code> says we just want a <code>Cashflow[...]</code> vector</li>
<li>… but if we wanted to extend this such that we got a vector containing cashflows, capital factors, default rates, etc we could define a new projection type (e.g.&nbsp;we might call the above <code>AssetDetailProjection()</code></li>
<li>As of the time of announcement, only <code>CashflowProjection()</code> is defined by FinanceModels.jl</li>
</ul></li>
</ul>
<section id="contracts-that-depend-on-the-model-or-multiple-models" class="level3">
<h3 class="anchored" data-anchor-id="contracts-that-depend-on-the-model-or-multiple-models">Contracts that depend on the model (or multiple models)</h3>
<p>For example, the cashflows you generate for a floating rate bond is the current reference rate. Or maybe you have a stochastic volatility model and want to project forward option values. This type of dependency is handled like this:</p>
<ul>
<li>define <code>model</code> as a relation that maps a key to a model. E.g. a <code>Dict("SOFR" =&gt; NelsonSiegelSvensson(...))</code></li>
<li>when defining the logic for the reducible collection/foldl, you can reference the <code>Projection.model</code> by the associated key.</li>
</ul>
<p>Here’s how a floating bond is implemented:</p>
<p>The contract struct. The <code>key</code> would be “SOFR” in our example above.</p>
<pre class="julia"><code>struct Floating{F&lt;:FinanceCore.Frequency,N&lt;:Real,M&lt;:Timepoint,K} &lt;: AbstractBond
    coupon_rate::N # coupon_rate / frequency is the actual payment amount
    frequency::F
    maturity::M
    key::K
end</code></pre>
<p>And how we can reference the associated model when projecting that contract. This is very similar to the definition of <code>__foldl__</code> for our <code>PrincipalOnlyBond</code>, except we are paying a coupon and referencing the scenario rate.</p>
<pre class="julia"><code>@inline function Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C&lt;:Bond.Floating,M,K}
    b = p.contract
    ts = Bond.coupon_times(b)
    for t in ts
        freq = b.frequency # e.g. `Periodic(2)`
        freq_scalar = freq.frequency  # the 2 from `Periodic(2)`

        # get the rate from the current time to next payment 
        # out of the model and convert it to the contract's periodicity
        model = p.model[b.key]
        reference_rate = rate(freq(forward(model, t, t + 1 / freq_scalar)))
        coup = (reference_rate + b.coupon_rate) / freq_scalar
        amt = if t == last(ts)
            1.0 + coup
        else
            coup
        end
        cf = Cashflow(amt, t)
        val = @next(rf, val, cf)
    end
    return complete(rf, val)
end</code></pre>
</section>
</section>
<section id="projectionkinds" class="level2">
<h2 class="anchored" data-anchor-id="projectionkinds">7. <code>ProjectionKind</code>s</h2>
<p>While <code>CashflowProjection</code> is the most common (and the only one built into the initial release of FinanceModels), a <code>Projection</code> can be created which handles different kinds of outputs in the same manner as projecting just basic cashflows. For example, you may want to output an amortization schedule, or a financial statement, or an account value roll-forward. The <code>Projection</code> is able to handle these custom outputs by dispatching on the third element in a <code>Projection</code>.</p>
<p>Let’s extend the example of a principle-only bond from section 2 above. Our goal is to create a basic amortization schedule which shows the payment made and outstanding balance.</p>
<p>First, we create a new subtype of <code>ProjectionKind</code>:</p>
<pre class="julia"><code>struct AmortizationSchedule &lt;: FinanceModels.ProjectionKind
end</code></pre>
<p>And then define the loop for the amortization schedule output:</p>
<pre class="julia"><code># note the dispatch on `AmortizationSchedule` in the next line
function Transducers.__foldl__(rf, val, p::Projection{C,M,K}) where {C&lt;:PrincipalOnlyBond,M,K&lt;:AmortizationSchedule}
    # initialization stuff
    b = p.contract # the contract within a projection
    ts = Bond.coupon_times(b) # works since it's a FinanceModels.Bond.AbstractBond with a frequency and maturity
    pmt = 1 / length(ts)
    balance = 1.0
    for t in ts
        # the loop which returns a tuple of the relevant data
        balance -= pmt
        result = (time=t,payment=pmt,outstanding=balance)
        val = @next(rf, val, result) # the value to return is the last argument
    end
    return complete(rf, val)
end</code></pre>
<p>We can now define the projection:</p>
<pre class="julia-repl"><code>julia&gt; p = Projection(
           PrincipalOnlyBond(Periodic(2),5.),  # our contract
           NullModel(),                       # the projection doesn't need a model, so use the null model
           AmortizationSchedule(),            # specify the amortization schedule output
           );
</code></pre>
<p>And then collect the values:</p>
<pre class="julia-repl"><code>julia&gt; collect(p)
10-element Vector{NamedTuple{(:time, :payment, :outstanding), Tuple{Float64, Float64, Float64}}}:
 (time = 0.5, payment = 0.1, outstanding = 0.9)
 (time = 1.0, payment = 0.1, outstanding = 0.8)
 (time = 1.5, payment = 0.1, outstnding = 0.7000000000000001)
 (time = 2.0, payment = 0.1, outstanding = 0.6000000000000001)
 (time = 2.5, payment = 0.1, outstanding = 0.5000000000000001)
 (time = 3.0, payment = 0.1, outstanding = 0.40000000000000013)
 (time = 3.5, payment = 0.1, outstanding = 0.30000000000000016)
 (time = 4.0, payment = 0.1, outstanding = 0.20000000000000015)
 (time = 4.5, payment = 0.1, outstanding = 0.10000000000000014)
 (time = 5.0, payment = 0.1, outstanding = 1.3877787807814457e-16)</code></pre>
</section>
<section id="development-benefits" class="level2">
<h2 class="anchored" data-anchor-id="development-benefits">Development Benefits</h2>
<p>In addition to the more composable code for the end-user, the package itself has been able to be simplified. Compared to Yields.jl, the lines of source code have been reduced by 30% while the number of lines of documentation has increased by over 20%.</p>
</section>
<section id="migration-guide" class="level2">
<h2 class="anchored" data-anchor-id="migration-guide">Migration Guide</h2>
<p>For those looking to upgrade from Yields (v3.x.x) to FinanceModels (v4+), there is a <a href="https://juliaactuary.github.io/FinanceModels.jl/dev/migration/">migration guide here</a>. Associated packages <a href="https://github.com/JuliaActuary/ActuaryUtilities.jl/pull/101#issue-1773044104">ActuaryUtilities.jl</a> and <a href="https://github.com/JuliaActuary/FinanceCore.jl/compare/v1.1.0...v2.0.0">FinanceCore.jl</a> had major version releases for minor breaking changes where most code should remain unaffected (FinanceCore is not intended to be user-facing).</p>
<p>Some tutorials or examples on the site may still use Yields.jl - that’s okay as they will still work given Julia’s strong degree of reproducibility and dependency management tools. Please open an issue on the <a href="https://github.com/JuliaActuary/JuliaActuary.org">JuliaActuary.org repository</a> if you have trouble with any of the old example code.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>In this post we’ve now defined two assets that can work seamlessly with projecting cashflows, fitting models, and determining valuations :)</p>
<p>FinanceModel.jl should provide the basis for a performant and composable design to facilitate further development and use by actuaries and other financial professionals.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/JuliaActuary\.github\.io\/JuliaActuary\.org\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>