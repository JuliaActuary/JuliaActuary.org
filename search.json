[
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "Packages",
    "section": "",
    "text": "These packages are available for use in your project. Scroll down for more information and links to the associated repository for each one."
  },
  {
    "objectID": "packages.html#adding-and-using-packages",
    "href": "packages.html#adding-and-using-packages",
    "title": "Packages",
    "section": "Adding and Using Packages",
    "text": "Adding and Using Packages\nThere are two ways to add packages:\n\nIn the code itself: using Pkg; Pkg.add(\"MortalityTables\")\nIn the REPL, hit ] to enter Pkg mode and type add MortalityTables More info can be found at the Pkg manager documentation.\n\nTo use packages in your code:\nusing PackageName"
  },
  {
    "objectID": "packages.html#mortalitytables.jl",
    "href": "packages.html#mortalitytables.jl",
    "title": "Packages",
    "section": "MortalityTables.jl",
    "text": "MortalityTables.jl\n\nHassle-free mortality and other rate tables.\n\n\nFeatures\n\nFull set of SOA mort.soa.org tables included\nsurvival and decrement functions to calculate decrements over period of time\nPartial year mortality calculations (Uniform, Constant, Balducci)\nFriendly syntax and flexible usage\nExtensive set of parametric mortality models.\n\n\n\nQuickstart\nLoad and see information about a particular table:\njulia&gt; vbt2001 = MortalityTables.table(\"2001 VBT Residual Standard Select and Ultimate - Male Nonsmoker, ANB\")\n\nMortalityTable (Insured Lives Mortality):\n   Name:\n       2001 VBT Residual Standard Select and Ultimate - Male Nonsmoker, ANB\n   Fields:\n       (:select, :ultimate, :metadata)\n   Provider:\n       Society of Actuaries\n   mort.SOA.org ID:\n       1118\n   mort.SOA.org link:\n       https://mort.soa.org/ViewTable.aspx?&TableIdentity=1118\n   Description:\n       2001 Valuation Basic Table (VBT) Residual Standard Select and Ultimate Table -  Male Nonsmoker.\n       Basis: Age Nearest Birthday. \n       Minimum Select Age: 0. \n       Maximum Select Age: 99. \n       Minimum Ultimate Age: 25. \n       Maximum Ultimate Age: 120\nThe package revolves around easy-to-access vectors which are indexed by attained age:\njulia&gt; vbt2001.select[35]          # vector of rates for issue age 35\n 0.00036\n 0.00048\n РІ«\n 0.94729\n 1.0\n \njulia&gt; vbt2001.select[35][35]      # issue age 35, attained age 35\n 0.00036\n \njulia&gt; vbt2001.select[35][50:end] # issue age 35, attained age 50 through end of table\n0.00316\n0.00345\n РІ«\n0.94729\n1.0\n\njulia&gt; vbt2001.ultimate[95]        # ultimate vectors only need to be called with the attained age\n 0.24298\nCalculate the force of mortality or survival over a range of time:\njulia&gt; survival(vbt2001.ultimate,30,40) # the survival between ages 30 and 40\n0.9894404665434904\n\njulia&gt; decrement(vbt2001.ultimate,30,40) # the decrement between ages 30 and 40\n0.010559533456509618\nNon-whole periods of time are supported when you specify the assumption (Constant(), Uniform(), or Balducci()) for fractional periods:\njulia&gt; survival(vbt2001.ultimate,30,40.5,Uniform()) # the survival between ages 30 and 40.5\n0.9887676470262408\n\n\nParametric Models\nOver 20 different models included. Example with the Gompertz model\nm = MortalityTables.Gompertz(a=0.01,b=0.2)\n\nm[20]                 # the mortality rate at age 20\ndecrement(m,20,25)    # the five year cumulative mortality rate\nsurvival(m,20,25) # the five year survival rate\nMortalityTables documentation ­ЪАГ\nMortalityTables package on Github ­ЪАГ"
  },
  {
    "objectID": "packages.html#actuaryutilities.jl",
    "href": "packages.html#actuaryutilities.jl",
    "title": "Packages",
    "section": "ActuaryUtilities.jl",
    "text": "ActuaryUtilities.jl\n\nA collection of common functions/manipulations used in Actuarial Calculations.\n\nA collection of common functions/manipulations used in Actuarial Calculations.\n\nQuickstart\ncfs = [5, 5, 105]\ntimes    = [1, 2, 3]\n\ndiscount_rate = 0.03\n\npresent_value(discount_rate, cfs, times)           # 105.65\nduration(Macaulay(), discount_rate, cfs, times)    #   2.86\nduration(discount_rate, cfs, times)                #   2.78\nconvexity(discount_rate, cfs, times)               #  10.62\n\n\nFeatures\n\nFinancial Maths\n\nduration:\n\nCalculate the Macaulay, Modified, or DV01 durations for a set of cashflows\n\nconvexity for price sensitivity\nFlexible interest rate options via the FinanceModels.jl package.\ninternal_rate_of_return or irr to calculate the IRR given cashflows (including at timepoints like ExcelРђЎs XIRR)\nbreakeven to calculate the breakeven time for a set of cashflows\naccum_offset to calculate accumulations like survivorship from a mortality vector\n\n\n\nKey Rate Sensitivities via Automatic Differentiation\nCompute exact key rate durations, DV01s, and convexities using ForwardDiff through ZeroRateCurve from FinanceModels.jl Рђћ machine-precision sensitivities in a single pass, no bump-and-reprice required.\n\nsensitivities: bundled value, key rate durations, and convexity matrix in a single AD pass\nTwo-curve decomposition: separate IR01 (risk-free) and CS01 (credit spread) sensitivities\nDo-block syntax for rate-dependent instruments (callable bonds, floaters)\nHull-White stochastic model: key rate sensitivities of Monte Carlo expected values\n\n\n\nOptions Pricing\n\neurocall and europut for Black-Scholes option prices\n\n\n\nRisk Measures\n\nCalculate risk measures for a given vector of risks:\n\nCTE for the Conditional Tail Expectation, or\nVaR for the percentile/Value at Risk.\n\n\n\n\nInsurance mechanics\n\nduration:\n\nCalculate the duration given an issue date and date (a.k.a. policy duration)\n\n\nActuaryUtilities documentation ­ЪАГ\nActuaryUtilities package on GitHub ­ЪАГ"
  },
  {
    "objectID": "packages.html#lifecontingencies.jl",
    "href": "packages.html#lifecontingencies.jl",
    "title": "Packages",
    "section": "LifeContingencies.jl",
    "text": "LifeContingencies.jl\n\nCommon life contingent calculations with a convenient interface.\n\n\nFeatures\n\nIntegration with other JuliaActuary packages such as MortalityTables.jl\nFast calculations, with some parts utilizing parallel processing power automatically\nUse functions that look more like the math you are used to (e.g.┬аA, a╠ѕ) with Unicode support\nAll of the power, speed, convenience, tooling, and ecosystem of Julia\nFlexible and modular modeling approach\n\n\n\nPackage Overview\n\nLeverages MortalityTables.jl for the mortality calculations\nContains common insurance calculations such as:\n\nInsurance(life,yield): Whole life\nInsurance(life,yield,n): Term life for n years\na╠ѕ(life,yield): present_value of life-contingent annuity\na╠ѕ(life,yield,n): present_value of life-contingent annuity due for n years\n\nContains various commutation functions such as D(x),M(x),C(x), etc.\nSingleLife and JointLife capable\nInterest rate mechanics via FinanceModels.jl\nMore documentation available by clicking the DOCS badges at the top of this README\n\n\n\nExamples\n\nBasic Functions\nCalculate various items for a 30-year-old male nonsmoker using 2015 VBT base table and a 5% interest rate\n\nusing LifeContingencies\nusing MortalityTables\nusing FinanceModels\nimport LifeContingencies: V, a╠ѕ     # pull the shortform notation into scope\n\n# load mortality rates from MortalityTables.jl\nvbt2001 = MortalityTables.table(\"2001 VBT Residual Standard Select and Ultimate - Male Nonsmoker, ANB\")\n\nissue_age = 30\nlife = SingleLife(                 # The life underlying the risk\n    mortality = vbt2001.select[issue_age],    # -- Mortality rates\n)\n\nyield = FinanceModels.Yield.Constant(0.05) \n\nlc = LifeContingency(life, yield)  # LifeContingency joins the risk with interest\n\n\nins = Insurance(lc)                # Whole Life insurance\nins = Insurance(life, yield)       # alternate way to construct\nWith the above life contingent data, we can calculate vectors of relevant information:\ncashflows(ins)                     # A vector of the unit cashflows\ntimepoints(ins)                    # The timepoints associated with the cashflows\nsurvival(ins)                      # The survival vector\nbenefit(ins)                       # The unit benefit vector\nprobability(ins)                   # The probability of benefit payment\nSome of the above will return lazy results. For example, cashflows(ins) will return a Generator which can be efficiently used in most places youРђЎd use a vector of cashflows (e.g.┬аpv(...) or sum(...)) but has the advantage of being non-allocating (less memory used, faster computations). To get a computed vector instead of the generator, simply call collect(...) on the result: collect(cashflows(ins)).\nOr calculate summary scalars:\npresent_value(ins)                 # The actuarial present value\npremium_net(lc)                    # Net whole life premium \nV(lc,5)                            # Net premium reserve for whole life insurance at time 5\nOther types of life contingent benefits:\nInsurance(lc,10)                 # 10 year term insurance\nAnnuityImmediate(lc)               # Whole life annuity due\nAnnuityDue(lc)                     # Whole life annuity due\na╠ѕ(lc)                              # Shortform notation\na╠ѕ(lc, 5)                           # 5 year annuity due\na╠ѕ(lc, 5, certain=5,frequency=4)    # 5 year annuity due, with 5 year certain payable 4x per year\n...                                # and more!\n\n\nConstructing Lives\nSingleLife(vbt2001.select[50])                 # no keywords, just a mortality vector\nSingleLife(vbt2001.select[50],issue_age = 60)  # select at 50, but now 60\nSingleLife(vbt2001.select,issue_age = 50)      # use issue_age to pick the right select vector\nSingleLife(mortality=vbt2001.select,issue_age = 50) # mort can also be a keyword\n\nLifeContingencies documentation ­ЪАГ\nLifeContingencies package on GitHub ­ЪАГ"
  },
  {
    "objectID": "packages.html#financemodels.jl",
    "href": "packages.html#financemodels.jl",
    "title": "Packages",
    "section": "FinanceModels.jl",
    "text": "FinanceModels.jl\n\nFlexible and composable yield curves and interest functions.\n\nFinanceModels.jl provides a set of composable contracts, models, and functions that allow for modeling of both simple and complex financial instruments. The resulting models, such as discount rates or term structures, can then be used across the JuliaActuary ecosystem to perform actuarial and financial analysis.\nAdditionally, the models can be used to project contracts through time: most basically as a series of cashflows but more complex output can be defined for contracts.\n\n\n\nYields Curve Fitting in FinanceModels.jl\n\n\n\nQuickStart\nusing FinanceModels\n\n# a set of market-observed prices we wish to calibrate the model to\n# annual effective unless otherwise specified\nq_rate = ZCBYield([0.01,0.02,0.03]);\nq_spread = ZCBYield([0.01,0.01,0.01]);\n\n# bootstrap a linear spline yield model\nmodel_rate = fit(Spline.Linear(),q_rate,Fit.Bootstrap());Рађ           \nmodel_spread = fit(Spline.Linear(),q_spread,Fit.Bootstrap());\n\n# the zero rate is the combination of the two underlying rates\nzero(m_spread + m_rate,1) # 0.02 annual effective rate \n\n# the discount is the same as if we added the underlying zero rates\ndiscount(m_spread + m_rate,0,3) РЅѕ discount(0.01 + 0.03,3)   # true\n\n# compute the present value of a contract (a cashflow of 10 at time 3)\npresent_value(m_rate,Cashflow(10,3)) # 9.15...\n\n\nOverview of FinanceModels\n\n\n\nA conceptual sketch of FinanceModels.jl\n\n\nOften we start with observed or assumed values for existing contracts. We want to then use those assumed values to extend the valuation logic to new contracts. For example, we may have a set of bond yields which we then want to discount a series of insurance obligations.\nIn the language of FinanceModels, we would have a set of Quotes which are used to fit a Model. That model is then used to discount a new series of cashflows.\nThatРђЎs just an example, and we can use the various components in different ways depending on the objective of the analysis.\n\n\nContracts and Quotes\nContracts are a way to represent financial obligations. These can be valued using a model, projected into a future steam of values, or combined with assumed prices as a Quote.\nIncluded are a number of primitives and convenience methods for contracts:\nExisting structs:\n\nCashflow\nBond.Fixed\nBond.Floating\nForward (an obligation with a forward start time)\nComposite (combine two other contracts, e.g.┬аinto a swap)\nEuroCall\nCommonEquity\nOption.Cap, Option.Floor, Option.Swaption (interest rate derivatives)\n\nCommonly, we deal with conventions that imply a contract and an observed price. For example, we may talk about a treasury yield of 0.03. This is a description that implies a Quoteed price for an underling fixed bond. In FinanceModels, we could use CMTYield(rate,tenor) which would create a Quote(price,Bond.Fixed(...)). In this way, we can conveniently create a number of Quotes which can be used to fit models. Such convenience methods include:\n\nZCBYield\nZCBPrice\nCMTYield\nParYield\nParSwapYield\nForwardYield\n\nFinanceModels offers a way to define new contracts as well.\n\nCashflows\nA Cashflows obligation are themselves a contract, but other contracts can be considered as essentially anything that can be combined with assumptions (a model) to derive a collection of cashflows.\nFor example, a obligation that pays 1.75 at time 2 could be represented as: Cashflow(1.75,2).\n\n\n\nModels\nModels are objects that can be fit to observed prices and then subsequently used to make valuations of other cashflows/contracts.\nYield models include:\n\nYield.Constant\nBootstrapped Splines\nYield.SmithWilson\nYield.NelsonSiegel\nYield.NelsonSiegelSvensson\n\n\nYield-related functions\nThe models can be used to compute various rates of interest:\n\ndiscount(curve,from,to) or discount(curve,to) gives the discount factor\naccumulation(curve,from,to) or accumulation(curve,to) gives the accumulation factor\nzero(curve,time) or zero(curve,time,Frequency) gives the zero-coupon spot rate for the given time.\nforward(curve,from,to) gives the zero rate between the two given times\npar(curve,time;frequency=2) gives the coupon-paying par equivalent rate for the given time.\n\n\n\nZeroRateCurve Рђћ Direct Construction\nConstruct a zero-rate curve directly from rates and tenors without fitting:\n\nMultiple interpolation options (MonotoneConvex default, Linear, PCHIP, Cubic, Akima)\nForwardDiff-compatible for AD-based sensitivities (key rate durations, DV01, convexity)\n\n\n\nStochastic Short-Rate Models\n\nShortRate.Vasicek, ShortRate.CoxIngersollRoss, ShortRate.HullWhite\nsimulate() for Monte Carlo rate path generation\npv_mc() for expected present values under stochastic rates\nClosed-form pricing for caps, floors, swaptions (Gaussian models)\n\nOther models include:\n\nBlackScholesMerton derivative valuation\n\n\n\n\nProjections\nMost basically, we can project a contract into a series of Cashflows:\njulia&gt; b = Bond.Fixed(0.04,Periodic(2),3)\nFinanceModels.Bond.Fixed{Periodic, Float64, Int64}(0.04, Periodic(2), 3)\n\njulia&gt; collect(b)\n6-element Vector{Cashflow{Float64, Float64}}:\n Cashflow{Float64, Float64}(0.02, 0.5)\n Cashflow{Float64, Float64}(0.02, 1.0)\n Cashflow{Float64, Float64}(0.02, 1.5)\n Cashflow{Float64, Float64}(0.02, 2.0)\n Cashflow{Float64, Float64}(0.02, 2.5)\n Cashflow{Float64, Float64}(1.02, 3.0)\nHowever, Projections allow one to combine three elements which can be extended to define any desired output (such as amortization schedules, financial statement projections, or account value rollforwards). The three elements are:\n\nthe underlying contract of interest\nthe model which includes assumptions of how the contract will behave\na ProjectionKind which indicates the kind of output desired (cashflow stream, amortization schedule, etcРђд)\n\n\n\nFitting Models\n       Model                                                               Method\n          |                                                                   |\n    |------------|                                                     |---------------|\nfit(Spline.Cubic(), CMTYield.([0.04,0.05,0.055,0.06,0055],[1,2,3,4,5]), Fit.Bootstrap())\n                    |-------------------------------------------------|\n                                              |\n                                              Quotes\n\nModel could be Spline.Linear(), Yield.NelsonSiegelSvensson(), Equity.BlackScholesMerton(...), etc.\nQuote could be CMTYields, ParYields, Option.Eurocall, etc.\nMethod could be Fit.Loss(x-&gt;x^2), Fit.Loss(x-&gt;abs(x)), Fit.Bootstrap(), etc.\n\nThis unified way to fit models offers a much simpler way to extend functionality to new models or contract types.\n\nUsing Models\nAfter being fit, models can be used to value contracts:\npresent_value(model,cashflows)\nAdditionally, ActuaryUtilities.jl offers a number of other methods that can be used, such as duration, convexity, price which can be used for analysis with the fitted models.\n\n\n\nRates\nRates are types that wrap scalar values to provide information about how to determine discount and accumulation factors.\nThere are two Frequency types:\n\nPeriodic(m) for rates that compound m times per period (e.g.┬аm times per year if working with annual rates).\nContinuous() for continuously compounding rates.\n\n\nExamples\nContinuous(0.05)       # 5% continuously compounded\nPeriodic(0.05,2)       # 5% compounded twice per period\nThese are both subtypes of the parent Rate type and are instantiated as:\nRate(0.05,Continuous())       # 5% continuously compounded\nRate(0.05,Periodic(2))        # 5% compounded twice per period\nRates can also be constructed by specifying the Frequency and then passing a scalar rate:\nPeriodic(1)(0.05)\nContinuous()(0.05)\n\n\nConversion\nConvert rates between different types with convert. E.g.:\nr = Rate(FinanceModels.Periodic(12),0.01)             # rate that compounds 12 times per rate period (ie monthly)\n\nconvert(FinanceModels.Periodic(1),r)                  # convert monthly rate to annual effective\nconvert(FinanceModels.Continuous(),r)          # convert monthly rate to continuous\n\n\nArithmetic\nAdding, substracting, multiplying, dividing, and comparing rates is supported.\nFinanceModels documentation ­ЪАГ\nFinanceModels package on GitHub ­ЪАГ"
  },
  {
    "objectID": "packages.html#experienceanalysis.jl",
    "href": "packages.html#experienceanalysis.jl",
    "title": "Packages",
    "section": "ExperienceAnalysis.jl",
    "text": "ExperienceAnalysis.jl\n\nMeeting your exposure calculation needs.\n\n\nQuickstart\ndf = DataFrame(\n    policy_id = 1:3,\n    issue_date = [Date(2020,5,10), Date(2020,4,5), Date(2019, 3, 10)],\n    end_date = [Date(2022, 6, 10), Date(2022, 8, 10), Date(2022,12,31)],\n    status = [\"claim\", \"lapse\", \"inforce\"]\n)\n\ndf.policy_year = exposure.(\n    ExperienceAnalysis.Anniversary(Year(1)),\n    df.issue_date,\n    df.end_date,\n    df.status .== \"claim\"; # continued exposure\n    study_start = Date(2020, 1, 1),\n    study_end = Date(2022, 12, 31)\n)\n\ndf = flatten(df, :policy_year)\n\ndf.exposure_fraction =\n        map(e -&gt; yearfrac(e.from, e.to + Day(1), DayCounts.Thirty360()), df.policy_year) \n# + Day(1) above because DayCounts has Date(2020, 1, 1) to Date(2021, 1, 1) as an exposure of 1.0\n# here we end the interval at Date(2020, 12, 31), so we need to add a day to get the correct exposure fraction.\n\n\n\n\n\n\n\n\n\n\n\npolicy_idInt64\nissue_dateDate\nend_dateDate\nstatusString\npolicy_year@NamedTuple{from::Date, to::Date, policy\\_timestep::Int64}\nexposure_fractionFloat64\n\n\n\n\n1\n2020-05-10\n2022-06-10\nclaim\n(from = Date(Рђю2020-05-10РђЮ), to = Date(Рђю2021-05-09РђЮ), policy_timestep = 1)\n1.0\n\n\n1\n2020-05-10\n2022-06-10\nclaim\n(from = Date(Рђю2021-05-10РђЮ), to = Date(Рђю2022-05-09РђЮ), policy_timestep = 2)\n1.0\n\n\n1\n2020-05-10\n2022-06-10\nclaim\n(from = Date(Рђю2022-05-10РђЮ), to = Date(Рђю2023-05-09РђЮ), policy_timestep = 3)\n1.0\n\n\n2\n2020-04-05\n2022-08-10\nlapse\n(from = Date(Рђю2020-04-05РђЮ), to = Date(Рђю2021-04-04РђЮ), policy_timestep = 1)\n1.0\n\n\n2\n2020-04-05\n2022-08-10\nlapse\n(from = Date(Рђю2021-04-05РђЮ), to = Date(Рђю2022-04-04РђЮ), policy_timestep = 2)\n1.0\n\n\n2\n2020-04-05\n2022-08-10\nlapse\n(from = Date(Рђю2022-04-05РђЮ), to = Date(Рђю2022-08-10РђЮ), policy_timestep = 3)\n0.35\n\n\n3\n2019-03-10\n2022-12-31\ninforce\n(from = Date(Рђю2020-01-01РђЮ), to = Date(Рђю2020-03-09РђЮ), policy_timestep = 1)\n0.191667\n\n\n3\n2019-03-10\n2022-12-31\ninforce\n(from = Date(Рђю2020-03-10РђЮ), to = Date(Рђю2021-03-09РђЮ), policy_timestep = 2)\n1.0\n\n\n3\n2019-03-10\n2022-12-31\ninforce\n(from = Date(Рђю2021-03-10РђЮ), to = Date(Рђю2022-03-09РђЮ), policy_timestep = 3)\n1.0\n\n\n3\n2019-03-10\n2022-12-31\ninforce\n(from = Date(Рђю2022-03-10РђЮ), to = Date(Рђю2022-12-31РђЮ), policy_timestep = 4)\n0.808333\n\n\n\n\n\nAvailable Exposure Basis\n\nExperienceAnalysis.Anniversary(period) will give exposures periods based on the first date\nExperienceAnalysis.Calendar(period) will follow calendar periods (e.g.┬аmonth or year)\nExperienceAnalysis.AnniversaryCalendar(period,period) will split into the smaller of the calendar or policy period.\n\nWhere period is a Period Type from the Dates standard library.\nCalculate exposures with exposures(basis,from,to,continue_exposure).\n\ncontinue_exposures indicates whether the exposure should be extended through the full exposure period rather than terminate at the to date.\n\nExperienceAnalysis documentation ­ЪАГ\nExperienceAnalysis package on GitHub ­ЪАГ"
  },
  {
    "objectID": "packages.html#economicscenariogenerators.jl",
    "href": "packages.html#economicscenariogenerators.jl",
    "title": "Packages",
    "section": "EconomicScenarioGenerators.jl",
    "text": "EconomicScenarioGenerators.jl\n\nEasy-to-use scenario generation thatРђЎs FinanceModels.jl compatible.\n\n\nModels\n\nInterest Rate Models\n\nVasicek\nCoxIngersolRoss\nHullWhite\n\n\n\nEquityModels\n\nBlackScholesMerton\n\n\n\n\nInterest Rate Model Examples\n\nVasicek\nm = Vasicek(0.136,0.0168,0.0119,Continuous(0.01)) # a, b, ¤Ѓ, initial Rate\ns = ScenarioGenerator(\n        1,  # timestep\n        30, # projection horizon\n        m,  # model\n    )\nThis can be iterated over, or you can collect all of the rates like:\nrates = collect(s)\nor\nfor r in s\n    # do something with r\nend\nAnd the package integrates with FinanceModels.jl:\nYieldCurve(s)\n\nwill produce a yield curve object:\n              РађРађРађРађРађРађРађРађРађРађРађРађРађРађYield Curve (FinanceModels.BootstrapCurve)РађРађРађРађРађРађРађРађРађРађРађРађРађ           \n              РћїРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћљ           \n         0.03 РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРацРацРаћРањРаЅРаЅРањРањРањРањРањРацРБёРБђРћѓ Zero rates\n              РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРацРањРањРаЅРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРаћРаіРаЂРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРаћРаІРаЂРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРбђРБђРБђРађРађРБђРАцРаќРаіРаЅРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРацРаќРаІРаЂРађРађРаЅРаЅРаЂРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРаћРаІРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n   Continuous РћѓРађРађРађРађРађРађРађРађРађРБђРАцРањРаЊРадРацРаќРаЅРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРађРађРађРађРађРађРађРб░РаІРаЂРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРађРађРБђРаќРабРАђРА░РаЃРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРаЅРаЅРаЂРађРађРаЅРаЂРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n            0 РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ           \n              РћћРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћў           \n              Рађ0РађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађtimeРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађ30Рађ           \nEconomicScenarioGenerators documentation ­ЪАГ\nEconomicScenarioGenerators package on GitHub ­ЪАГ"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "JuliaActuary",
    "section": "",
    "text": "Practical, extensible, and open-source actuarial modeling and analysis.\n\n\n\n\nDesigned for speed and efficiency, enabling high-performance numerical computing, quantitative analysis, modeling, and simulation.\n\n\n\nExtensive ecosystem of libraries and tools catering to technical computing, data science, machine learning, and domain-specific tasks in finance and actuarial science.\n\n\n\nClean, readable syntax, comprehensive documentation, and seamless integration with existing languages and tools enhance productivity and accessibility for a wide range of users.\nJuliaActuary is an ecosystem of packages that makes Julia the easiest language to get started for actuarial workflows.\nJulia is an ideal language for Actuaries and other financial professionals.\nIt is free, open-source software and you can join the development on Github."
  },
  {
    "objectID": "index.html#code-examples",
    "href": "index.html#code-examples",
    "title": "JuliaActuary",
    "section": "Code Examples",
    "text": "Code Examples\n\n    \n        \n        \n          \n    Getting Mortality Tables\n  \njulia&gt; using MortalityTables\n\njulia&gt; MortalityTables.table(\"2015 VBT Smoker Distinct Male Non-Smoker ALB\")\nMortalityTable (Insured Lives Mortality):\n   Name:\n       2015 VBT Smoker Distinct Male Non-Smoker ALB\n   Fields:\n       (:select, :ultimate, :metadata)\n   Provider:\n       American Academy of Actuaries along with the Society of Actuaries\n   mort.SOA.org ID:\n       3269\n   mort.SOA.org link:\n       https://mort.soa.org/ViewTable.aspx?&TableIdentity=3269\n   Description:\n       2015 Valuation Basic Table (VBT) Smoker Distinct Table...\n       \n        \n        \n        \n          \n        Working with Yield Curves\n  \n\n\njulia&gt; using FinanceModels\n\njulia&gt; maturities = [0.5, 1.0, 1.5, 2.0]\njulia&gt; rates      = [5.0, 5.8, 6.4, 6.8] ./ 100\njulia&gt; quotes     = ZCBYield.(rates,maturities)\n\njulia&gt; rf_curve = fit(Spline.Cubic(), quotes, Fit.Bootstrap())\n\n\n               РађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађYield Curve (FinanceModels.YieldCurve)РађРађРађРађРађРађРађРађРађРађРађРађРађРађРађ\n               РћїРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћљ\n           0.4 РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ Zero rates\n               РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n               РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n               РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРАаРацРањРаІРћѓ\n               РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРбђРБђРацРаќРаіРаЅРаЂРађРађРађРађРћѓ\n               РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРАцРаћРањРаІРаЂРађРађРађРађРађРађРађРађРађРађРћѓ\n               РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРАаРацРањРаіРаЅРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n   Periodic(1) РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРАаРацРаќРаіРаЅРаЂРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n               РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРАаРацРаќРаіРаЅРаЂРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n               РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРБђРАаРацРањРаіРаЅРаЂРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n               РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРбђРБђРАцРацРањРаІРаЅРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n               РћѓРађРађРађРађРађРађРађРБђРАаРацРаќРањРаЅРаЂРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n               РћѓРађРбђРАаРацРањРаІРаЅРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n               РћѓРаЅРаЂРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n             0 РћѓРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРћѓ\n               РћћРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћў\n               Рађ0РађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађtimeРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађРађ30Рађ\n\n\n        \n                \n        \n                \n          \n        Financial Maths\n  \n\njulia&gt; using ActuaryUtilities\n\njulia&gt; cashflows = [5, 5, 105]\njulia&gt; discount_rate = 0.03\n\njulia&gt; present_value(discount_rate, cashflows)           \n105.65\n\njulia&gt; duration(Macaulay(), discount_rate, cashflows)    \n2.86\n\njulia&gt; duration(discount_rate, cashflows)                \n2.78\n\njulia&gt; convexity(discount_rate, cashflows)               \n10.62\n\n\n        \n                \n        \n                \n          \n        Life Contingencies\n  \nusing LifeContingencies\nusing MortalityTables\nusing FinanceModels\n\n# load mortality rates from MortalityTables.jl\nvbt2015 = MortalityTables.table(\"2015 VBT Smoker Distinct Male Non-Smoker ALB\")\n\nissue_age = 30\nlife = SingleLife(                       # The life underlying the risk\n    mortality = vbt2015.select[issue_age],    # -- Mortality rates\n)\n\nyield = Yield.Constant(0.05)            # Using a flat 5% interest rate\n\nins = Insurance(life, yield)             # alternate way to construct\n\n# Summary Scalars\npresent_value(ins)                       # The actuarial present value\npremium_net(lc)                          # Net whole life premium \nV(lc,5)                                  # Net premium reserve for whole life insurance at time 5"
  },
  {
    "objectID": "index.html#packages",
    "href": "index.html#packages",
    "title": "JuliaActuary",
    "section": "Packages",
    "text": "Packages\nThese packages are available for use in your project. See more on the Packages page.\nMortalityTables.jl - Easily work with standard mort.SOA.org tables and parametric models with common survival calculations.\nLifeContingencies.jl - Insurance, annuity, premium, and reserve maths.\nActuaryUtilities.jl - Robust and fast calculations for internal_rate_of_return, duration, convexity, present_value, breakeven, and AD-based key rate sensitivities.\nFinanceModels.jl - Composable contracts, models, and functions for financial instruments Рђћ including stochastic short-rate models and Monte Carlo simulation.\nExperienceAnalysis.jl - Meeting your exposure calculation needs.\nEconomicScenarioGenerators.jl - Easy-to-use scenario generation thatРђЎs FinanceModels.jl compatible."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "FinanceModels.jl - Evolving the JuliaActuary Ecosystem\n\n\n\ncode\n\nblog\n\n\n\n\n\n\n\n\n\nAug 19, 2023\n\n\nAlec Loudenback\n\n\n\n\n\n\n\n\n\n\n\n\nModern Bayesian Statistics for Actuaries\n\n\n\ncode\n\nstatistics\n\nblog\n\n\n\n\n\n\n\n\n\nJul 13, 2023\n\n\nAlec Loudenback\n\n\n\n\n\n\n\n\n\n\n\n\nJuliaActuary and Hacktoberfest 2022\n\n\n\ncode\n\ncontributing\n\nblog\n\n\n\n\n\n\n\n\n\nSep 24, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nGetting Started with Julia for Actuaries\n\n\n\nindustry\n\nblog\n\nstatistics\n\nbayesian\n\n\n\n\n\n\n\n\n\nOct 24, 2021\n\n\nAlec Loudenback and Dimitar Vanguelov\n\n\n\n\n\n\n\n\n\n\n\n\nThe Life Modeling Problem: A Comparison of Julia, Rust, Python, and R\n\n\n\ncode\n\nblog\n\n\n\n\n\n\n\n\n\nMay 16, 2021\n\n\nAlec Loudenback\n\n\n\n\n\n\n\n\n\n\n\n\nJulia for Actuaries\n\n\n\ncode\n\nindustry\n\nr\n\npython\n\nblog\n\n\n\n\n\n\n\n\n\nJul 9, 2020\n\n\nAlec Loudenback\n\n\n\n\n\n\n\n\n\n\n\n\nCoding the Future\n\n\n\ncode\n\nindustry\n\nblog\n\n\n\n\n\n\n\n\n\nJul 9, 2020\n\n\nAlec Loudenback\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "benchmarks.html",
    "href": "benchmarks.html",
    "title": "Benchmarks",
    "section": "",
    "text": "Inspired by the discussion in the ActuarialOpenSource GitHub community discussion, folks started submitted solutions to what someone referred to as the РђюLife Modeling ProblemРђЮ. This user submitted a short snippet for consideration of a representative problem.\n\n\nAfter the original user submitted a proposal, others chimed in and submitted versions in their favorite languages. I have collected those versions, and run them on a consistent set of hardware.\nSome submissions were excluded because from the benchmarks they involved an entirely different approach, such as memoizing the function calls[^1].\n\n\n\n\nTable┬а1: Benchmarks for the Life Modeling Problem in nanoseconds (lower times are better).\n\n\n\n18├Ќ6 DataFrame\n\n\n\nRow\nlang\nalgorithm\nfunction_name\nmedian\nmean\nrelative_mean\n\n\n\nString15\nString15\nString15\nFloat64?\nFloat64\nFloat64\n\n\n\n\n1\nJulia\nAccumulator\nnpv9\n6.388\n6.375\n1.0\n\n\n2\nRust\nAccumulator\nnpv3\n7.0\n7.0\n1.09804\n\n\n3\nJulia\nAccumulator\nnpv8\n7.372\n7.375\n1.15686\n\n\n4\nJulia\nAccumulator\nnpv7\n7.92\n7.917\n1.24188\n\n\n5\nJulia\nAccumulator\nnpv6\n9.037\n9.009\n1.41318\n\n\n6\nJulia\nAccumulator\nnpv4\n10.764\n10.761\n1.688\n\n\n7\nJulia\nAccumulator\nnpv5\n11.49\n11.469\n1.79906\n\n\n8\nRust\nAccumulator\nnpv2\n14.0\n14.0\n2.19608\n\n\n9\nJulia\nAccumulator\nnpv3\n14.507\n14.487\n2.27247\n\n\n10\nRust\nAccumulator\nnpv1\n22.0\n22.0\n3.45098\n\n\n11\nJulia\nVectorized\nnpv2\n235.758\n218.391\n34.2574\n\n\n12\nJulia\nVectorized\nnpv1\n235.322\n228.198\n35.7958\n\n\n13\nPython (Numba)\nAccumulator\nnpv_numba\nmissing\n626.0\n98.1961\n\n\n14\nPython\nAccumulator\nnpv_loop\nmissing\n2314.0\n362.98\n\n\n15\nPython (NumPy)\nVectorized\nnpv\nmissing\n14261.0\n2237.02\n\n\n16\nR\nVectorized\nnpv base\n4264.0\n46617.0\n7312.47\n\n\n17\nR\nAccumulator\nnpv_loop\n4346.0\n62275.7\n9768.74\n\n\n18\nR (data.table)\nVectorized\nnpv\n770554.0\n8.42767e5\n1.32199e5\n\n\n\n\n\n\n\n\n\nTo aid in visualizing results with such vast different orders of magnitude, this graph includes a physical length comparison to serve as a reference. The computation time is represented by the distance that light travels in the time for the computation to complete (comparing a nanosecond to one foot length goes at least back to Admiral Grace Hopper).\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure┬а1\n\n\n\n\n\n\n\nFor more a more in-depth discussion of these results, see this post.\nAll of the benchmarked code can be found in the JuliaActuary Learn repository. Please file an issue or submit a PR request there for issues/suggestions."
  },
  {
    "objectID": "benchmarks.html#the-life-modeling-problem",
    "href": "benchmarks.html#the-life-modeling-problem",
    "title": "Benchmarks",
    "section": "",
    "text": "Inspired by the discussion in the ActuarialOpenSource GitHub community discussion, folks started submitted solutions to what someone referred to as the РђюLife Modeling ProblemРђЮ. This user submitted a short snippet for consideration of a representative problem.\n\n\nAfter the original user submitted a proposal, others chimed in and submitted versions in their favorite languages. I have collected those versions, and run them on a consistent set of hardware.\nSome submissions were excluded because from the benchmarks they involved an entirely different approach, such as memoizing the function calls[^1].\n\n\n\n\nTable┬а1: Benchmarks for the Life Modeling Problem in nanoseconds (lower times are better).\n\n\n\n18├Ќ6 DataFrame\n\n\n\nRow\nlang\nalgorithm\nfunction_name\nmedian\nmean\nrelative_mean\n\n\n\nString15\nString15\nString15\nFloat64?\nFloat64\nFloat64\n\n\n\n\n1\nJulia\nAccumulator\nnpv9\n6.388\n6.375\n1.0\n\n\n2\nRust\nAccumulator\nnpv3\n7.0\n7.0\n1.09804\n\n\n3\nJulia\nAccumulator\nnpv8\n7.372\n7.375\n1.15686\n\n\n4\nJulia\nAccumulator\nnpv7\n7.92\n7.917\n1.24188\n\n\n5\nJulia\nAccumulator\nnpv6\n9.037\n9.009\n1.41318\n\n\n6\nJulia\nAccumulator\nnpv4\n10.764\n10.761\n1.688\n\n\n7\nJulia\nAccumulator\nnpv5\n11.49\n11.469\n1.79906\n\n\n8\nRust\nAccumulator\nnpv2\n14.0\n14.0\n2.19608\n\n\n9\nJulia\nAccumulator\nnpv3\n14.507\n14.487\n2.27247\n\n\n10\nRust\nAccumulator\nnpv1\n22.0\n22.0\n3.45098\n\n\n11\nJulia\nVectorized\nnpv2\n235.758\n218.391\n34.2574\n\n\n12\nJulia\nVectorized\nnpv1\n235.322\n228.198\n35.7958\n\n\n13\nPython (Numba)\nAccumulator\nnpv_numba\nmissing\n626.0\n98.1961\n\n\n14\nPython\nAccumulator\nnpv_loop\nmissing\n2314.0\n362.98\n\n\n15\nPython (NumPy)\nVectorized\nnpv\nmissing\n14261.0\n2237.02\n\n\n16\nR\nVectorized\nnpv base\n4264.0\n46617.0\n7312.47\n\n\n17\nR\nAccumulator\nnpv_loop\n4346.0\n62275.7\n9768.74\n\n\n18\nR (data.table)\nVectorized\nnpv\n770554.0\n8.42767e5\n1.32199e5\n\n\n\n\n\n\n\n\n\nTo aid in visualizing results with such vast different orders of magnitude, this graph includes a physical length comparison to serve as a reference. The computation time is represented by the distance that light travels in the time for the computation to complete (comparing a nanosecond to one foot length goes at least back to Admiral Grace Hopper).\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure┬а1\n\n\n\n\n\n\n\nFor more a more in-depth discussion of these results, see this post.\nAll of the benchmarked code can be found in the JuliaActuary Learn repository. Please file an issue or submit a PR request there for issues/suggestions."
  },
  {
    "objectID": "benchmarks.html#irrs",
    "href": "benchmarks.html#irrs",
    "title": "Benchmarks",
    "section": "IRRs",
    "text": "IRRs\nTask: determine the IRR for a series of cashflows 701 elements long (e.g.┬аmonthly cashflows for 60 years).\n\nBenchmarks\n\nTimes are in nanoseconds:\nРћїРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћгРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћгРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћгРћђРћђРћђРћђРћђРћђРћђРћђРћђРћгРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћгРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћљ\nРћѓ Language Рћѓ          Package Рћѓ          Function Рћѓ  Median Рћѓ        Mean Рћѓ Relative Mean Рћѓ\nРћюРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ╝РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ╝РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ╝РћђРћђРћђРћђРћђРћђРћђРћђРћђРћ╝РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ╝РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћц\nРћѓ   Python Рћѓ  numpy_financial Рћѓ               irr Рћѓ missing Рћѓ   519306422 Рћѓ       123146x Рћѓ\nРћѓ   Python Рћѓ           better Рћѓ irr_binary_search Рћѓ missing Рћѓ     3045229 Рћѓ          722x Рћѓ\nРћѓ   Python Рћѓ           better Рћѓ        irr_newton Рћѓ missing Рћѓ      382166 Рћѓ           91x Рћѓ\nРћѓ    Julia Рћѓ ActuaryUtilities Рћѓ               irr Рћѓ    4185 Рћѓ        4217 Рћѓ            1x Рћѓ\nРћћРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ┤РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ┤РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ┤РћђРћђРћђРћђРћђРћђРћђРћђРћђРћ┤РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ┤РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћў\n\n\n\nDiscussion\nThe ActuaryUtilities implementation is over 100,000 times faster than numpy_financial, and 91 to 722 times faster than the better Python package. The ActuaryUtilities.jl implementation is also more flexible, as it can be given an argument with timepoints, similar to ExcelРђЎs XIRR.\nExcel was used to attempt a benchmark, but the IRR formula returned a #DIV/0! error.\nAll of the benchmarked code can be found in the JuliaActuary Learn repository. Please file an issue or submit a PR request there for issues/suggestions."
  },
  {
    "objectID": "benchmarks.html#black-scholes-merton-european-option-pricing",
    "href": "benchmarks.html#black-scholes-merton-european-option-pricing",
    "title": "Benchmarks",
    "section": "Black-Scholes-Merton European Option Pricing",
    "text": "Black-Scholes-Merton European Option Pricing\nTask: calculate the price of a vanilla european call option using the Black-Scholes-Merton formula.\n\\[\\begin{align}\nC(S_t, t) &= N(d_1)S_t - N(d_2)Ke^{-r(T - t)} \\\\\n\nd_1 &= \\frac{1}{\\sigma\\sqrt{T - t}}\\left[\\ln\\left(\\frac{S_t}{K}\\right) + \\left(r + \\frac{\\sigma^2}{2}\\right)(T - t)\\right] \\\\\n\nd_2 &= d_1 - \\sigma\\sqrt{T - t}\n\n\\end{align}\\]\n\nBenchmarks\nTimes are in nanoseconds:\nРћїРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћгРћђРћђРћђРћђРћђРћђРћђРћђРћђРћгРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћгРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћљ\nРћѓ Language Рћѓ  Median Рћѓ        Mean Рћѓ Relative Mean Рћѓ\nРћюРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ╝РћђРћђРћђРћђРћђРћђРћђРћђРћђРћ╝РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ╝РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћц\nРћѓ   Python Рћѓ missing Рћѓ    817000.0 Рћѓ       19926.0 Рћѓ\nРћѓ        R Рћѓ  3649.0 Рћѓ      3855.2 Рћѓ          92.7 Рћѓ\nРћѓ    Julia Рћѓ    41.0 Рћѓ        41.6 Рћѓ           1.0 Рћѓ\nРћћРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ┤РћђРћђРћђРћђРћђРћђРћђРћђРћђРћ┤РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћ┤РћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћђРћў\n\n\nDiscussion\nJulia is nearly 20,000 times faster than Python, and two orders of magnitude faster than R."
  },
  {
    "objectID": "benchmarks.html#other-benchmarks",
    "href": "benchmarks.html#other-benchmarks",
    "title": "Benchmarks",
    "section": "Other benchmarks",
    "text": "Other benchmarks\nThese benchmarks have been performed by others, but provide relevant information for actuarial-related work:\n\nH2Oai DataFrames/Database-like Operations\nReading CSVs"
  },
  {
    "objectID": "benchmarks.html#colophone",
    "href": "benchmarks.html#colophone",
    "title": "Benchmarks",
    "section": "Colophone",
    "text": "Colophone\n\nCode\nAll of the benchmarked code can be found in the JuliaActuary Learn repository. Please file an issue or submit a PR request there for issues/suggestions."
  },
  {
    "objectID": "benchmarks.html#footnotes",
    "href": "benchmarks.html#footnotes",
    "title": "Benchmarks",
    "section": "Footnotes",
    "text": "Footnotes\n[^1] If benchmarking memoization, itРђЎs essentially benchmarking how long it takes to perform hashing in a language. While interesting, especially in the context of incremental computing, itРђЎs not the core issue at hand. Incremental computing libraries exist for all of the modern languages discussed here.\n[^2] Note that not all languages have both a mean and median result in their benchmarking libraries. Mean is a better representation for a garbage-collected modern language, because sometimes the computation just takes longer than the median result. Where the mean is not available in the graph below, median is substituted."
  },
  {
    "objectID": "all-posts.html",
    "href": "all-posts.html",
    "title": "All Posts",
    "section": "",
    "text": "Interactive Cashflow Analysis with ActuaryUtilities.jl\n\n\n\nactuaryutilities\n\nfinancemodels\n\nassets\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUniversal Life Policy Account Mechanics as a Differential Equation\n\n\n\nmodeling\n\ndiffeq\n\nmortalitytables\n\nactuaryutilities\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUS Treasury Comparison Tool\n\n\n\nmodeling\n\nfinancemodels\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBayesian Markov-Chain-Monte-Carlo and Claims Data\n\n\n\nmortalitytables\n\nexposures\n\nexperience-analysis\n\ndataframes\n\ntutorial\n\nstatistics\n\nbayesian\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNested Projection Mechanics\n\n\n\nmodeling\n\nbenchmark\n\nactuaryutilities\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing MortaltiyTables.jl with DataFrames\n\n\n\nmortalitytables\n\ndataframes\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPoisson approximation to Binomial\n\n\n\nmodeling\n\nstatistics\n\nexperience-analysis\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBayesian vs Limited Fluctuation Experience Analysis\n\n\n\nmodeling\n\nstatistics\n\nexperience-analysis\n\nbayesian\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFitting Rate Data to Yield Curves\n\n\n\nmarket\n\nyieldcurves\n\nfinancemodels\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFitting survival data with MortaltityTables.jl\n\n\n\nsurvival\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive AAA Economic Scenario Generator\n\n\n\nmodeling\n\nscenario-generator\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStochastic claims projections demo\n\n\n\nmodeling\n\nbenchmark\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExposure Calculation with ExperienceAnalysis.jl\n\n\n\nmortalitytables\n\nexposures\n\nexperience-analysis\n\ndataframes\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReplicating the AAA equtity generator\n\n\n\nmodeling\n\nscenario-generator\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAutodifferentiation and Asset Liability Management (AAD & ALM)\n\n\n\nmodeling\n\nautodiff\n\nalm\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive Mortality Comparison Tool\n\n\n\nexperience-analysis\n\nmortalitytables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinanceModels.jl - Evolving the JuliaActuary Ecosystem\n\n\n\ncode\n\nblog\n\n\n\n\n\n\n\n\n\nAug 19, 2023\n\n\nAlec Loudenback\n\n\n\n\n\n\n\n\n\n\n\n\nModern Bayesian Statistics for Actuaries\n\n\n\ncode\n\nstatistics\n\nblog\n\n\n\n\n\n\n\n\n\nJul 13, 2023\n\n\nAlec Loudenback\n\n\n\n\n\n\n\n\n\n\n\n\nJuliaActuary and Hacktoberfest 2022\n\n\n\ncode\n\ncontributing\n\nblog\n\n\n\n\n\n\n\n\n\nSep 24, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nGetting Started with Julia for Actuaries\n\n\n\nindustry\n\nblog\n\nstatistics\n\nbayesian\n\n\n\n\n\n\n\n\n\nOct 24, 2021\n\n\nAlec Loudenback and Dimitar Vanguelov\n\n\n\n\n\n\n\n\n\n\n\n\nThe Life Modeling Problem: A Comparison of Julia, Rust, Python, and R\n\n\n\ncode\n\nblog\n\n\n\n\n\n\n\n\n\nMay 16, 2021\n\n\nAlec Loudenback\n\n\n\n\n\n\n\n\n\n\n\n\nJulia for Actuaries\n\n\n\ncode\n\nindustry\n\nr\n\npython\n\nblog\n\n\n\n\n\n\n\n\n\nJul 9, 2020\n\n\nAlec Loudenback\n\n\n\n\n\n\n\n\n\n\n\n\nCoding the Future\n\n\n\ncode\n\nindustry\n\nblog\n\n\n\n\n\n\n\n\n\nJul 9, 2020\n\n\nAlec Loudenback\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "learn.html",
    "href": "learn.html",
    "title": "Learn",
    "section": "",
    "text": "Resources to help get started."
  },
  {
    "objectID": "learn.html#installation",
    "href": "learn.html#installation",
    "title": "Learn",
    "section": "Installation",
    "text": "Installation\nAfter installing Julia from the official website, head to the Packages to see how to install JuliaActuary packages."
  },
  {
    "objectID": "learn.html#documentation",
    "href": "learn.html#documentation",
    "title": "Learn",
    "section": "Documentation",
    "text": "Documentation\nBrowse the unified documentation for all packages, or see individual package details on the Packages page."
  },
  {
    "objectID": "learn.html#introductory-programming-and-julia-resources",
    "href": "learn.html#introductory-programming-and-julia-resources",
    "title": "Learn",
    "section": "Introductory Programming and Julia Resources",
    "text": "Introductory Programming and Julia Resources\n\nJuliaLang.org, the home site with the downloads to get started, and links to learning resources.\nJuliaHub indexes open-source Julia packages and makes the entire ecosystem and documentation searchable from one place.\nJuliaAcademy, which has free short courses in Data Science, Introduction to Julia, DataFrames.jl, Machine Learning, and more.\nData Science Tutorials from the Alan Turing Institute.\nLearn Julia in Y minutes, a great quick-start if you are already comfortable with coding.\nThink Julia, a free e-book (or paid print edition) book which introduces programming from the start and teaches you valuable ways of thinking.\nDesign Patterns and Best Practices, a book that will help you as you transition from smaller, one-off scripts to designing larger packages and projects."
  },
  {
    "objectID": "learn.html#example-actuarial-and-finance-uses",
    "href": "learn.html#example-actuarial-and-finance-uses",
    "title": "Learn",
    "section": "Example Actuarial and Finance Uses",
    "text": "Example Actuarial and Finance Uses\nSee the examples page."
  },
  {
    "objectID": "learn.html#get-help",
    "href": "learn.html#get-help",
    "title": "Learn",
    "section": "Get Help",
    "text": "Get Help\n\nAsk questions or suggest ideas\n\n\nDiscussion and Questions\nIf you have other ideas or questions, join the JuliaActuary Github Discussions. Or come say hello on the community Zulip or Slack #actuary channel. We welcome all actuarial and related disciplines!\n\n\nHelp mode\nYou can also access help text when using the packages in the REPL by activating help mode, e.g.:\njulia&gt; ? survival\n    survival(mortality_vector,to_age)\n    survival(mortality_vector,from_age,to_age)\n\n\n  Returns the survival through attained age to_age. The start of the \n  calculation is either the start of the vector, or attained age `from_age` \n  and `to_age` need to be Integers. \n\n  Add a DeathDistribution as the last argument to handle floating point \n  and non-whole ages:\n\n    survival(mortality_vector,to_age,::DeathDistribution)\n    survival(mortality_vector,from_age,to_age,::DeathDistribution)\n\n\n  If given a negative to_age, it will return 1.0. Aside from simplifying the code, \n  this makes sense as for something to exist in order to decrement in the first place, \n  it must have existed and survived to the point of being able to be decremented.\n\n  Examples\n  РЅАРЅАРЅАРЅАРЅАРЅАРЅАРЅАРЅАРЅА\n\n  julia&gt; qs = UltimateMortality([0.1,0.3,0.6,1]);\n\n  julia&gt; survival(qs,0)\n  1.0\n  julia&gt; survival(qs,1)\n  0.9\n\n  julia&gt; survival(qs,1,1)\n  1.0\n  julia&gt; survival(qs,1,2)\n  0.7\n\n  julia&gt; survival(qs,0.5,Uniform())\n  0.95"
  },
  {
    "objectID": "learn.html#integration-with-r-and-python",
    "href": "learn.html#integration-with-r-and-python",
    "title": "Learn",
    "section": "Integration with R and Python",
    "text": "Integration with R and Python\n\nUse other languages seamlessly\n\nJulia integrates with other languages, allowing you to leverage existing scripts and packages in R via RCall and in Python via PyCall."
  },
  {
    "objectID": "learn.html#contributing",
    "href": "learn.html#contributing",
    "title": "Learn",
    "section": "Contributing",
    "text": "Contributing\n\nContribute code or report issues.\n\n&lt;mark&gt;Thank you&lt;/mark&gt; for your interest in modern actuarial solutions, no matter how you participate in the community.&lt;/p&gt;\n\nPull Requests\nJuliaActuary is open source; you are free to modify, use, or change your copy of the code - but if you make enhancements please consider opening a pull request (basic walkthrough here). Beginners are welcome and we can help with your first pull request!\n\n\nIssues\nIf you find issues, please open an issue on the relevant packageРђЎs repository and we will try and address it as soon as possible.\n\n\nProject Board\nSee the Good first Issues project board on Github for simple, self-contained ways to contribute such as adding small new features, improving the documentation, or writing up a tutorial on how to do something simple!"
  },
  {
    "objectID": "learn.html#other-inquiries",
    "href": "learn.html#other-inquiries",
    "title": "Learn",
    "section": "Other Inquiries",
    "text": "Other Inquiries\nFor more directed inquires, please send email to inquiry@JuliaActuary.org."
  },
  {
    "objectID": "learn.html#share",
    "href": "learn.html#share",
    "title": "Learn",
    "section": "Share",
    "text": "Share\nFollow JuliaActuary on LinkedIn for updates and to share with colleagues!"
  }
]